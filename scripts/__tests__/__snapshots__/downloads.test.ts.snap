// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`downloads/with-beads > should match snapshot for add-command.md 1`] = `
"---
description: Guide for creating new slash commands
argument-hint: <command-name> <description>
---

## General Guidelines

### Output Style

- **Never explicitly mention TDD** in code, comments, commits, PRs, or issues
- Write natural, descriptive code without meta-commentary about the development process
- The code should speak for itself - TDD is the process, not the product

Beads is available for task tracking. Use \`mcp__beads__*\` tools to manage issues (the user interacts via \`bd\` commands).

# Slash Command Creator Guide

## How This Command Works

The \`/add-command\` command shows this guide for creating new slash commands. It includes:

- Command structure and syntax
- Common patterns and examples
- Security restrictions and limitations
- Frontmatter options

**Note for AI**: When creating commands, you CAN use bash tools like \`Bash(mkdir:*)\`, \`Bash(ls:*)\`, \`Bash(git status:*)\` in the \`allowed-tools\` frontmatter of NEW commands - but ONLY for operations within the current project directory. This command itself doesn't need bash tools since it's just documentation.

## Command Locations

- **Personal**: \`~/.claude/commands/\` (available across all projects)
- **Project**: \`.claude/commands/\` (shared with team, shows "(project)")

## Basic Structure

\`\`\`markdown
---
allowed-tools: Read, Glob, Grep, Bash(git status:*), Task
description: Brief description of what this command does
argument-hint: [required-arg] [optional-arg]
---

# Command Title

Your command instructions here.

Arguments: $ARGUMENTS

File reference: @path/to/file.js

Bash command output: (exclamation)git status(backticks)
\`\`\`

## ‚ö†Ô∏è Security Restrictions

**Bash Commands (exclamation prefix)**: Limited to current working directory only.

- ‚úÖ Works: \`! + backtick + git status + backtick\` (in project dir)
- ‚ùå Blocked: \`! + backtick + ls /outside/project + backtick\` (outside project)  
- ‚ùå Blocked: \`! + backtick + pwd + backtick\` (if referencing dirs outside project)

**File References (\`@\` prefix)**: No directory restrictions.

- ‚úÖ Works: \`@/path/to/system/file.md\`
- ‚úÖ Works: \`@../other-project/file.js\`

## Common Patterns

### Simple Command

\`\`\`bash
echo "Review this code for bugs and suggest fixes" > ~/.claude/commands/review.md
\`\`\`

### Command with Arguments

**Note for AI**: The example below uses a fullwidth dollar sign (ÔºÑ, U+FF04) to prevent interpolation in this documentation. When creating actual commands, use the regular \`$\` character.

\`\`\`markdown
Fix issue ÔºÑARGUMENTS following our coding standards
\`\`\`

### Command with File References

\`\`\`markdown
Compare @src/old.js with @src/new.js and explain differences
\`\`\`

### Command with Bash Output (Project Directory Only)

\`\`\`markdown
---
allowed-tools: Bash(git status:*), Bash(git branch:*), Bash(git log:*)
---
Current status: (!)git status(\`)
Current branch: (!)git branch --show-current(\`)
Recent commits: (!)git log --oneline -5(\`)

Create commit for these changes.
\`\`\`

**Note**: Only works with commands in the current project directory.

### Namespaced Command

**Note for AI**: The example below uses a fullwidth dollar sign (ÔºÑ, U+FF04) to prevent interpolation in this documentation. When creating actual commands, use the regular \`$\` character.

\`\`\`bash
mkdir -p ~/.claude/commands/ai
echo "Ask GPT-5 about: ÔºÑARGUMENTS" > ~/.claude/commands/ai/gpt5.md
# Creates: /ai:gpt5
\`\`\`

## Frontmatter Options

- \`allowed-tools\`: Tools this command can use
  - **Important**: Intrusive tools like \`Write\`, \`Edit\`, \`NotebookEdit\` should NEVER be allowed in commands unless the user explicitly requests them. These tools modify files and should only be used when the command's purpose is to make changes.
  - ‚úÖ Safe for most commands: \`Read\`, \`Glob\`, \`Grep\`, \`Bash(git status:*)\`, \`Task\`, \`AskUserQuestion\`
- \`description\`: Brief description (shows in /help)
- \`argument-hint\`: Help text for arguments
- \`model\`: Specific model to use

## Best Practices

### Safe Commands (No Security Issues)

\`\`\`markdown
# System prompt editor (file reference only)  
(@)path/to/system/prompt.md

Edit your system prompt above.
\`\`\`

### Project-Specific Commands (Bash OK)

\`\`\`markdown
---
allowed-tools: Bash(git status:*), Bash(npm list:*)
---
Current git status: (!)git status(\`)
Package info: (!)npm list --depth=0(\`)

Review project state and suggest next steps.
\`\`\`

### Cross-Directory File Access (Use @ not !)

\`\`\`markdown
# Compare config files
Compare (@)path/to/system.md with (@)project/config.md

Show differences and suggest improvements.
\`\`\`

## Usage

After creating: \`/<command-name> [arguments]\`

Example: \`/review\` or \`/ai:gpt5 "explain this code"\`
"
`;

exports[`downloads/with-beads > should match snapshot for ask.md 1`] = `
"---
description: Request team review and approval - for complex changes needing discussion
argument-hint: [optional-pr-title-and-description]
---

# Ask - Request Review and Approval

## General Guidelines

### Output Style

- **Never explicitly mention TDD** in code, comments, commits, PRs, or issues
- Write natural, descriptive code without meta-commentary about the development process
- The code should speak for itself - TDD is the process, not the product

Beads is available for task tracking. Use \`mcp__beads__*\` tools to manage issues (the user interacts via \`bd\` commands).

**Ship/Show/Ask Pattern - ASK**

Ask is for complex changes that need team discussion and approval. Examples:

- Breaking API changes
- New architecture decisions
- Significant feature additions
- Performance trade-offs
- Security-sensitive changes

## When to Ask

Use **Ask** when:

- Changes affect multiple systems
- Breaking changes are needed
- You need input on approach
- Security implications exist
- Performance trade-offs need discussion
- Uncertain about the best solution

## Workflow

Current branch status:
!\`git status\`

Recent commits:
!\`git log --oneline -5\`

Arguments: $ARGUMENTS

**This is the traditional Pull Request workflow**, but with explicit intent that review and approval are required.

**Process:**

1. **Ensure Branch is Ready**:
   !\`git status\`
   - Commit all changes
   - Push to remote: \`git push origin [branch-name]\`

2. **Create Ask PR**: Create a PR that clearly needs review

   Title: conventional commits format, prefixed with \`[ASK]\`

   Description template:

   \`\`\`markdown
   ## ü§î Ask - Review and Approval Needed

   **This is an ASK PR**: These changes need team review and discussion.

   <!--
     References: [link to relevant issues]
   -->

   ### What changed

   [Detailed description of changes]

   ### Why

   [Rationale and context]

   ### Questions for reviewers

   - [ ] Question 1
   - [ ] Question 2

   ### Concerns

   - Potential concern 1
   - Potential concern 2

   ### Test Plan

   - [ ] Unit tests
   - [ ] Integration tests
   - [ ] Manual testing steps

   ### Alternatives considered

   - Alternative 1: [why not chosen]
   - Alternative 2: [why not chosen]
   \`\`\`

3. **Request Reviewers**: Assign specific reviewers who should weigh in

4. **Add Labels**:
   - "needs-review"
   - "breaking-change" (if applicable)
   - "security" (if applicable)

5. **Link Issues**: Reference related issues in the description

6. **Monitor Discussion**: Be responsive to reviewer feedback and questions

## Use GitHub MCP Tools

1. Check current branch and ensure it's pushed
2. Create a well-formatted pull request with [ASK] prefix
3. Set reviewers
4. Add appropriate labels
5. Link related issues from commit messages

## Decision Guide

Use **Ask** when:

- ‚úÖ Change is complex or risky
- ‚úÖ Breaking changes involved
- ‚úÖ Need team input on approach
- ‚úÖ Multiple solutions possible
- ‚úÖ Security implications

Use **/show** instead if: confident in approach, just want visibility

Use **/ship** instead if: change is tiny, obvious, and safe

### Beads Integration

Use Beads MCP to:

- Track work with \`bd ready\` to find next task
- Create issues with \`bd create "description"\`
- Track dependencies with \`bd dep add\`

See <https://github.com/steveyegge/beads> for more information.
"
`;

exports[`downloads/with-beads > should match snapshot for beepboop.md 1`] = `
"---
description: Communicate AI-generated content with transparent attribution
argument-hint: <task-description>
---

# AI-Attributed Communication Command

Execute the user's requested task (e.g., posting PR comments, GitHub issue comments, or other communications through various MCPs), but frame the output with clear AI attribution.

## General Guidelines

### Output Style

- **Never explicitly mention TDD** in code, comments, commits, PRs, or issues
- Write natural, descriptive code without meta-commentary about the development process
- The code should speak for itself - TDD is the process, not the product

Beads is available for task tracking. Use \`mcp__beads__*\` tools to manage issues (the user interacts via \`bd\` commands).

## Instructions

Arguments: $ARGUMENTS

**IMPORTANT Communication Format:**

1. **Opening**: Begin with "*Beep boop, I am Claude Code ü§ñ, my user has reviewed and approved the following written by me:*"
   - Use italics for this line
   - Clearly establishes AI authorship

2. **Middle**: Perform the requested task (post comment, create review, etc.)
   - Execute whatever communication task the user requested
   - Write the actual content that accomplishes the user's goal

3. **Closing**: End with "*Beep boop, Claude Code ü§ñ out!*"
   - Use italics for this line
   - Provides clear closure

## Purpose

This command ensures transparency about AI usage while maintaining that the user has reviewed and approved the content. It prevents offloading review responsibility to other users while being open about AI assistance.

## Examples

- Posting a GitHub PR review comment
- Adding a comment to a GitHub issue
- Responding to feedback with AI-generated explanations
- Any communication where AI attribution is valuable
"
`;

exports[`downloads/with-beads > should match snapshot for busycommit.md 1`] = `
"---
description: Create multiple atomic git commits, one logical change at a time
argument-hint: [optional-commit-description]
---

## General Guidelines

### Output Style

- **Never explicitly mention TDD** in code, comments, commits, PRs, or issues
- Write natural, descriptive code without meta-commentary about the development process
- The code should speak for itself - TDD is the process, not the product

Beads is available for task tracking. Use \`mcp__beads__*\` tools to manage issues (the user interacts via \`bd\` commands).

Create multiple atomic git commits, committing the smallest possible logical unit at a time

Include any of the following info if specified: $ARGUMENTS

## Commit Message Rules

Follows [Conventional Commits](https://www.conventionalcommits.org/) standard.

1. **Format**: \`type(#issue): description\`
   - Use \`#123\` for local repo issues
   - Use \`owner/repo#123\` for cross-repo issues
   - Common types: \`feat\`, \`fix\`, \`docs\`, \`refactor\`, \`test\`, \`chore\`

2. **AI Credits**: **NEVER include AI credits in commit messages**
   - No "Generated with Claude Code"
   - No "Co-Authored-By: Claude" or "Co-Authored-By: Happy"
   - Focus on the actual changes made, not conversation history

3. **Content**: Write clear, concise commit messages describing what changed and why

## Process

1. Run \`git status\` and \`git diff\` to review changes
2. Run \`git log --oneline -5\` to see recent commit style
3. Stage relevant files with \`git add\`
4. Create commit with descriptive message
5. Verify with \`git status\`

## Example

\`\`\`bash
git add <files>
git commit -m "feat(#123): add validation to user input form"
\`\`\`

## Atomic Commit Approach

Each commit should represent ONE logical change. Do NOT bundle multiple unrelated changes into one commit.

- Identify the smallest atomic units of change
- For EACH atomic unit: stage only those files/hunks, commit, verify
- Use \`git add -p\` to stage partial file changes when a file contains multiple logical changes
- Repeat until all changes are committed
- It is OK to create multiple commits without stopping - keep going until \`git status\` shows clean

## Multi-Commit Example

If a single file contains multiple unrelated changes, use \`git add -p\` to stage hunks interactively:

\`\`\`bash
# Stage only the validation-related hunks from the file
git add -p src/user-service.ts
# Select 'y' for validation hunks, 'n' for others
git commit -m "feat(#123): add email format validation"

# Stage the error handling hunks
git add -p src/user-service.ts
git commit -m "fix(#124): handle null user gracefully"

# Stage remaining changes
git add src/user-service.ts
git commit -m "refactor: extract user lookup to helper"
\`\`\`
"
`;

exports[`downloads/with-beads > should match snapshot for code-review.md 1`] = `
"---
description: Code review using dynamic category detection and domain-specific analysis
argument-hint: (optional) [branch, PR#, or PR URL] - defaults to current branch
  - Bash(git diff:*)
  - Bash(git status:*)
  - Bash(git log:*)
  - Bash(git rev-parse:*)
  - Bash(git merge-base:*)
  - Bash(git branch:*)
---

## General Guidelines

### Output Style

- **Never explicitly mention TDD** in code, comments, commits, PRs, or issues
- Write natural, descriptive code without meta-commentary about the development process
- The code should speak for itself - TDD is the process, not the product

Beads is available for task tracking. Use \`mcp__beads__*\` tools to manage issues (the user interacts via \`bd\` commands).

# Code Review

Perform a code review using dynamic category detection.

## Phase 0: Setup & Categorization

### Determine What to Review

Parse the argument to determine the review target:

| Input | Action |
|-------|--------|
| No argument | Detect divergence point, confirm scope with user |
| Branch name | Use specified branch as base |
| PR number (e.g., \`123\`) | Fetch PR diff from GitHub |
| PR URL (e.g., \`https://github.com/owner/repo/pull/123\`) | Extract PR number and fetch diff |

**For GitHub PRs:**

1. Try GitHub MCP first: \`mcp__github__pull_request_read\` with \`method: "get_diff"\`
2. Fall back to \`gh\` CLI: \`gh pr diff <number>\`
3. If neither works, report error and stop

**For local branches (no argument or branch name provided):**

1. **Get current branch**: \`git rev-parse --abbrev-ref HEAD\`

2. **Check for uncommitted changes**: \`git status --porcelain\`
   - If output is non-empty, note that uncommitted changes exist

3. **Detect divergence point** (skip if branch name was provided as argument):
   - Get all local branches except current: \`git branch --format='%(refname:short)'\`
   - For each branch, find merge-base: \`git merge-base HEAD <branch>\`
   - Count commits from merge-base to HEAD: \`git rev-list --count <merge-base>..HEAD\`
   - The branch with the **fewest commits back** (closest merge-base) is the likely parent
   - If no other branches exist, fall back to \`main\`, \`master\`, or \`develop\` if they exist as remote tracking branches

4. **Confirm scope with user** using \`AskUserQuestion\`:

   **Question 1 - "Review scope"** (header: "Base branch"):
   - Option A: \`From <detected-branch>\` ‚Äî "Review N commits since diverging from <branch>"
   - Option B: \`Different branch\` ‚Äî "Specify another branch to compare against"
   - Option C: \`Uncommitted only\` ‚Äî "Review only staged/unstaged changes, skip committed work"

   **Question 2 - "Include uncommitted?"** (header: "Uncommitted", only ask if uncommitted changes exist AND user didn't pick option C):
   - Option A: \`Yes\` ‚Äî "Include N staged/unstaged files in review"
   - Option B: \`No\` ‚Äî "Review only committed changes"

5. **Collect changed files** based on user selection:
   - From branch: \`git diff --name-only <base>...HEAD\`
   - Uncommitted unstaged: \`git diff --name-only\`
   - Uncommitted staged: \`git diff --name-only --cached\`
   - Combine and deduplicate the file list

6. **If no changes**: Report "Nothing to review" and stop

### Categorize Files

Check for CLAUDE.md - if it exists, note any project-specific review patterns.

Categorize each changed file into ONE primary category based on these patterns:

| Category | File Patterns |
|----------|---------------|
| Frontend/UI | \`*.tsx\`, \`*.jsx\`, \`components/\`, \`pages/\`, \`views/\`, \`*.vue\` |
| Frontend/Styling | \`*.css\`, \`*.scss\`, \`*.less\`, \`styles/\`, \`*.tailwind*\`, \`*.styled.*\` |
| Backend/API | \`routes/\`, \`api/\`, \`controllers/\`, \`services/\`, \`*.controller.*\`, \`*.service.*\`, \`*.resolver.*\` |
| Backend/Data | \`migrations/\`, \`models/\`, \`prisma/\`, \`schema.*\`, \`*.model.*\`, \`*.entity.*\` |
| Tooling/Config | \`scripts/\`, \`*.config.*\`, \`package.json\`, \`tsconfig.*\`, \`vite.*\`, \`webpack.*\`, \`eslint.*\` |
| CI/CD | \`.github/\`, \`.gitlab-ci.*\`, \`Dockerfile\`, \`docker-compose.*\`, \`*.yml\` in CI paths |
| Tests | \`*.test.*\`, \`*.spec.*\`, \`__tests__/\`, \`__mocks__/\`, \`*.stories.*\` |
| Docs | \`*.md\`, \`docs/\`, \`README*\`, \`CHANGELOG*\` |

Output the categorization:

\`\`\`
## Categorization

Base branch: <branch>
Total files changed: <n>

| Category | Files |
|----------|-------|
| <category> | <count> |
...
\`\`\`

## Phase 1: Branch Brief

From the diff and recent commit messages (\`git log <base>...HEAD --oneline\`), infer:

- **Goal**: What this branch accomplishes (1-3 sentences)
- **Constraints**: Any implied requirements (security, performance, backwards compatibility)
- **Success checklist**: What must work after this change, what must not break

\`\`\`
## Branch Brief

**Goal**: ...
**Constraints**: ...
**Checklist**:
- [ ] ...
\`\`\`

## Phase 2: Category Reviews

For each detected category with changes, run a targeted review. Skip categories with no changes.

### Frontend/UI Review Criteria

- Accessibility: ARIA attributes, keyboard navigation, screen reader support
- Component patterns: Composition, prop drilling, context usage
- State management: Unnecessary re-renders, stale closures
- Performance: memo/useMemo/useCallback usage, lazy loading, bundle impact

### Frontend/Styling Review Criteria

- Responsive design: Breakpoints, mobile-first
- Design system: Token usage, consistent spacing/colors
- CSS specificity: Overly specific selectors, !important usage
- Theme support: Dark mode, CSS variables

### Backend/API Review Criteria

- Input validation: Sanitization, type checking, bounds
- Security: Authentication checks, authorization, injection risks
- Error handling: Proper status codes, meaningful messages, logging
- Performance: N+1 queries, missing indexes, pagination

### Backend/Data Review Criteria

- Migration safety: Reversibility, data preservation
- Data integrity: Constraints, foreign keys, nullability
- Index usage: Queries have appropriate indexes
- Backwards compatibility: Existing data still works

### Tooling/Config Review Criteria

- Breaking changes: Does this affect developer workflow?
- Dependency compatibility: Version conflicts, peer deps
- Build performance: Added build time, bundle size

### CI/CD Review Criteria

- Secrets exposure: Credentials in logs, env vars
- Pipeline efficiency: Caching, parallelization
- Failure handling: Notifications, rollback strategy

### Tests Review Criteria

- Coverage: Edge cases, error paths, boundaries
- Assertion quality: Specific assertions, not just "no error"
- Flaky patterns: Timing dependencies, order dependencies, shared state

### Docs Review Criteria

- Technical accuracy: Code examples work, APIs documented correctly
- Completeness: All new features documented
- Clarity: Easy to follow, good examples

**Output format per category:**

\`\`\`
## <Category> Review (<n> files)

### file:line - [blocker|risky|nit] Title
Description of the issue and why it matters.
Suggested fix or question to investigate.

...
\`\`\`

## Phase 3: Cross-Cutting Analysis

After reviewing all categories, check for cross-cutting issues:

- API changed but tests didn't update?
- New feature but no documentation?
- Migration added but no rollback tested?
- Config changed but README not updated?
- Security-sensitive code without corresponding test?

\`\`\`
## Cross-Cutting Issues

- [ ] <issue description>
...
\`\`\`

## Phase 4: Summary

### PR Description (draft)

Provide a ready-to-paste PR description:

\`\`\`
## What changed
- <by category, 1-2 bullets each>

## Why
- <motivation>

## Testing
- <how to verify>

## Notes
- <migration steps, breaking changes, etc.>
\`\`\`

### Review Checklist

\`\`\`
## Before Merge

### Blockers (must fix)
- [ ] ...

### Risky (highlight to reviewers)
- [ ] ...

### Follow-ups (can defer)
- [ ] ...
\`\`\`

---

Review target (branch name, PR number, or PR URL - leave empty for current branch): $ARGUMENTS
"
`;

exports[`downloads/with-beads > should match snapshot for commit.md 1`] = `
"---
description: Create a git commit following project standards
argument-hint: [optional-commit-description]
---

## General Guidelines

### Output Style

- **Never explicitly mention TDD** in code, comments, commits, PRs, or issues
- Write natural, descriptive code without meta-commentary about the development process
- The code should speak for itself - TDD is the process, not the product

Beads is available for task tracking. Use \`mcp__beads__*\` tools to manage issues (the user interacts via \`bd\` commands).

Create a git commit following project standards

Include any of the following info if specified: $ARGUMENTS

## Commit Message Rules

Follows [Conventional Commits](https://www.conventionalcommits.org/) standard.

1. **Format**: \`type(#issue): description\`
   - Use \`#123\` for local repo issues
   - Use \`owner/repo#123\` for cross-repo issues
   - Common types: \`feat\`, \`fix\`, \`docs\`, \`refactor\`, \`test\`, \`chore\`

2. **AI Credits**: **NEVER include AI credits in commit messages**
   - No "Generated with Claude Code"
   - No "Co-Authored-By: Claude" or "Co-Authored-By: Happy"
   - Focus on the actual changes made, not conversation history

3. **Content**: Write clear, concise commit messages describing what changed and why

## Process

1. Run \`git status\` and \`git diff\` to review changes
2. Run \`git log --oneline -5\` to see recent commit style
3. Stage relevant files with \`git add\`
4. Create commit with descriptive message
5. Verify with \`git status\`

## Example

\`\`\`bash
git add <files>
git commit -m "feat(#123): add validation to user input form"
\`\`\`
"
`;

exports[`downloads/with-beads > should match snapshot for cycle.md 1`] = `
"---
description: Execute complete TDD cycle - Red, Green, and Refactor phases in sequence
argument-hint: <feature or requirement description>
---

RED+GREEN+REFACTOR (one cycle) PHASE! Apply the below to the info given by user input here:

$ARGUMENTS

## General Guidelines

### Output Style

- **Never explicitly mention TDD** in code, comments, commits, PRs, or issues
- Write natural, descriptive code without meta-commentary about the development process
- The code should speak for itself - TDD is the process, not the product

Beads is available for task tracking. Use \`mcp__beads__*\` tools to manage issues (the user interacts via \`bd\` commands).

(If there was no info above, fallback to:

1. Context of the conversation, if there's an immediate thing
2. \`bd ready\` to see what to work on next and start from there)

## TDD Fundamentals

### The TDD Cycle

The foundation of TDD is the Red-Green-Refactor cycle:

1. **Red Phase**: Write ONE failing test that describes desired behavior

   - The test must fail for the RIGHT reason (not syntax/import errors)
   - Only one test at a time - this is critical for TDD discipline
     - Exception: For browser-level tests or expensive setup (e.g., Storybook \`*.stories.tsx\`), group multiple assertions within a single test block to avoid redundant setup - but only when adding assertions to an existing interaction flow. If new user interactions are required, still create a new test. Split files by category if they exceed ~1000 lines.
   - **Adding a single test to a test file is ALWAYS allowed** - no prior test output needed
   - Starting TDD for a new feature is always valid, even if test output shows unrelated work
   - For DOM-based tests, use \`data-testid\` attributes to select elements rather than CSS classes, tag names, or text content
   - Avoid hard-coded timeouts both in form of sleep() or timeout: 5000 etc; use proper async patterns (\`waitFor\`, \`findBy*\`, event-based sync) instead and rely on global test configs for timeout settings

2. **Green Phase**: Write MINIMAL code to make the test pass

   - Implement only what's needed for the current failing test
   - No anticipatory coding or extra features
   - Address the specific failure message

3. **Refactor Phase**: Improve code structure while keeping tests green
   - Only allowed when relevant tests are passing
   - Requires proof that tests have been run and are green
   - Applies to BOTH implementation and test code
   - No refactoring with failing tests - fix them first

### Core Violations

1. **Multiple Test Addition**

   - Adding more than one new test at once
   - Exception: Initial test file setup or extracting shared test utilities

2. **Over-Implementation**

   - Code that exceeds what's needed to pass the current failing test
   - Adding untested features, methods, or error handling
   - Implementing multiple methods when test only requires one

3. **Premature Implementation**
   - Adding implementation before a test exists and fails properly
   - Adding implementation without running the test first
   - Refactoring when tests haven't been run or are failing

### Critical Principle: Incremental Development

Each step in TDD should address ONE specific issue:

- Test fails "not defined" ‚Üí Create empty stub/class only
- Test fails "not a function" ‚Üí Add method stub only
- Test fails with assertion ‚Üí Implement minimal logic only

### Optional Pre-Phase: Spike Phase

In rare cases where the problem space, interface, or expected behavior is unclear, a **Spike Phase** may be used **before the Red Phase**.
This phase is **not part of the regular TDD workflow** and must only be applied under exceptional circumstances.

- The goal of a Spike is **exploration and learning**, not implementation.
- The code written during a Spike is **disposable** and **must not** be merged or reused directly.
- Once sufficient understanding is achieved, all spike code is discarded, and normal TDD resumes starting from the **Red Phase**.
- A Spike is justified only when it is impossible to define a meaningful failing test due to technical uncertainty or unknown system behavior.

### General Information

- Sometimes the test output shows as no tests have been run when a new test is failing due to a missing import or constructor. In such cases, allow the agent to create simple stubs. Ask them if they forgot to create a stub if they are stuck.
- It is never allowed to introduce new logic without evidence of relevant failing tests. However, stubs and simple implementation to make imports and test infrastructure work is fine.
- In the refactor phase, it is perfectly fine to refactor both test and implementation code. That said, completely new functionality is not allowed. Types, clean up, abstractions, and helpers are allowed as long as they do not introduce new behavior.
- Adding types, interfaces, or a constant in order to replace magic values is perfectly fine during refactoring.
- Provide the agent with helpful directions so that they do not get stuck when blocking them.
"
`;

exports[`downloads/with-beads > should match snapshot for gap.md 1`] = `
"---
description: Analyze conversation context for unaddressed items and gaps
argument-hint: [optional additional info]
---

## General Guidelines

### Output Style

- **Never explicitly mention TDD** in code, comments, commits, PRs, or issues
- Write natural, descriptive code without meta-commentary about the development process
- The code should speak for itself - TDD is the process, not the product

Beads is available for task tracking. Use \`mcp__beads__*\` tools to manage issues (the user interacts via \`bd\` commands).

Analyze the current conversation context and identify things that have not yet been addressed. Look for:

1. **Incomplete implementations** - Code that was started but not finished
2. **Unused variables/results** - Values that were captured but never used
3. **Missing tests** - Functionality without test coverage
4. **Open issues** - Beads issues that are still open or in progress

5. **User requests** - Things the user asked for that weren't fully completed
6. **TODO comments** - Any TODOs mentioned in conversation
7. **Error handling gaps** - Missing error cases or edge cases
8. **Documentation gaps** - Undocumented APIs or features
9. **Consistency check** - Look for inconsistent patterns, naming conventions, or structure across the codebase

Present findings as a prioritized list with:

- What the gap is
- Why it matters
- Suggested next action

If there are no gaps, confirm that everything discussed has been addressed.

Additional info:
$ARGUMENTS
"
`;

exports[`downloads/with-beads > should match snapshot for green.md 1`] = `
"---
description: Execute TDD Green Phase - write minimal implementation to pass the failing test
argument-hint: <implementation description>
---

GREEN PHASE! Apply the below to the info given by user input here:

$ARGUMENTS

## General Guidelines

### Output Style

- **Never explicitly mention TDD** in code, comments, commits, PRs, or issues
- Write natural, descriptive code without meta-commentary about the development process
- The code should speak for itself - TDD is the process, not the product

Beads is available for task tracking. Use \`mcp__beads__*\` tools to manage issues (the user interacts via \`bd\` commands).

(If there was no info above, fallback to:

1. Context of the conversation, if there's an immediate thing
2. \`bd ready\` to see what to work on next and start from there)

## TDD Fundamentals

### The TDD Cycle

The foundation of TDD is the Red-Green-Refactor cycle:

1. **Red Phase**: Write ONE failing test that describes desired behavior

   - The test must fail for the RIGHT reason (not syntax/import errors)
   - Only one test at a time - this is critical for TDD discipline
     - Exception: For browser-level tests or expensive setup (e.g., Storybook \`*.stories.tsx\`), group multiple assertions within a single test block to avoid redundant setup - but only when adding assertions to an existing interaction flow. If new user interactions are required, still create a new test. Split files by category if they exceed ~1000 lines.
   - **Adding a single test to a test file is ALWAYS allowed** - no prior test output needed
   - Starting TDD for a new feature is always valid, even if test output shows unrelated work
   - For DOM-based tests, use \`data-testid\` attributes to select elements rather than CSS classes, tag names, or text content
   - Avoid hard-coded timeouts both in form of sleep() or timeout: 5000 etc; use proper async patterns (\`waitFor\`, \`findBy*\`, event-based sync) instead and rely on global test configs for timeout settings

2. **Green Phase**: Write MINIMAL code to make the test pass

   - Implement only what's needed for the current failing test
   - No anticipatory coding or extra features
   - Address the specific failure message

3. **Refactor Phase**: Improve code structure while keeping tests green
   - Only allowed when relevant tests are passing
   - Requires proof that tests have been run and are green
   - Applies to BOTH implementation and test code
   - No refactoring with failing tests - fix them first

### Core Violations

1. **Multiple Test Addition**

   - Adding more than one new test at once
   - Exception: Initial test file setup or extracting shared test utilities

2. **Over-Implementation**

   - Code that exceeds what's needed to pass the current failing test
   - Adding untested features, methods, or error handling
   - Implementing multiple methods when test only requires one

3. **Premature Implementation**
   - Adding implementation before a test exists and fails properly
   - Adding implementation without running the test first
   - Refactoring when tests haven't been run or are failing

### Critical Principle: Incremental Development

Each step in TDD should address ONE specific issue:

- Test fails "not defined" ‚Üí Create empty stub/class only
- Test fails "not a function" ‚Üí Add method stub only
- Test fails with assertion ‚Üí Implement minimal logic only

### Optional Pre-Phase: Spike Phase

In rare cases where the problem space, interface, or expected behavior is unclear, a **Spike Phase** may be used **before the Red Phase**.
This phase is **not part of the regular TDD workflow** and must only be applied under exceptional circumstances.

- The goal of a Spike is **exploration and learning**, not implementation.
- The code written during a Spike is **disposable** and **must not** be merged or reused directly.
- Once sufficient understanding is achieved, all spike code is discarded, and normal TDD resumes starting from the **Red Phase**.
- A Spike is justified only when it is impossible to define a meaningful failing test due to technical uncertainty or unknown system behavior.

### General Information

- Sometimes the test output shows as no tests have been run when a new test is failing due to a missing import or constructor. In such cases, allow the agent to create simple stubs. Ask them if they forgot to create a stub if they are stuck.
- It is never allowed to introduce new logic without evidence of relevant failing tests. However, stubs and simple implementation to make imports and test infrastructure work is fine.
- In the refactor phase, it is perfectly fine to refactor both test and implementation code. That said, completely new functionality is not allowed. Types, clean up, abstractions, and helpers are allowed as long as they do not introduce new behavior.
- Adding types, interfaces, or a constant in order to replace magic values is perfectly fine during refactoring.
- Provide the agent with helpful directions so that they do not get stuck when blocking them.
"
`;

exports[`downloads/with-beads > should match snapshot for issue.md 1`] = `
"---
description: Analyze GitHub issue and create TDD implementation plan
argument-hint: [optional-issue-number]
---

Analyze GitHub issue and create TDD implementation plan.

## General Guidelines

### Output Style

- **Never explicitly mention TDD** in code, comments, commits, PRs, or issues
- Write natural, descriptive code without meta-commentary about the development process
- The code should speak for itself - TDD is the process, not the product

Beads is available for task tracking. Use \`mcp__beads__*\` tools to manage issues (the user interacts via \`bd\` commands).

Process:

1. Get Issue Number

- Either from branch name use that issue number
  - Patterns: issue-123, 123-feature, feature/123, fix/123
- Or from this bullet point with custom info: $ARGUMENTS
- If not found: ask user

1. Fetch Issue

Try to fetch the issue using GitHub MCP (mcp__github__issue_read tool).

If GitHub MCP is not configured, show:

\`\`\`
GitHub MCP not configured!
See: https://github.com/modelcontextprotocol/servers/tree/main/src/github
Trying GitHub CLI fallback...
\`\`\`

Then try using \`gh issue view [ISSUE_NUMBER] --json\` as fallback.

1. Analyze and Plan

Summarize the issue and requirements, then:

## Discovery Phase

Understand the requirement by asking (use AskUserQuestion if needed):

**Problem Statement**

- What problem does this solve?
- Who experiences this problem?
- What's the current pain point?

**Desired Outcome**

- What should happen after this is built?
- How will users interact with it?
- What does success look like?

**Scope & Constraints**

- What's in scope vs. out of scope?
- Any technical constraints?
- Dependencies on other systems/features?

**Context Check**

- Search codebase for related features/modules
- Check for existing test files that might be relevant

### Beads Integration

Use Beads MCP to:

- Track work with \`bd ready\` to find next task
- Create issues with \`bd create "description"\`
- Track dependencies with \`bd dep add\`

See <https://github.com/steveyegge/beads> for more information.

## TDD Fundamentals

### The TDD Cycle

The foundation of TDD is the Red-Green-Refactor cycle:

1. **Red Phase**: Write ONE failing test that describes desired behavior

   - The test must fail for the RIGHT reason (not syntax/import errors)
   - Only one test at a time - this is critical for TDD discipline
     - Exception: For browser-level tests or expensive setup (e.g., Storybook \`*.stories.tsx\`), group multiple assertions within a single test block to avoid redundant setup - but only when adding assertions to an existing interaction flow. If new user interactions are required, still create a new test. Split files by category if they exceed ~1000 lines.
   - **Adding a single test to a test file is ALWAYS allowed** - no prior test output needed
   - Starting TDD for a new feature is always valid, even if test output shows unrelated work
   - For DOM-based tests, use \`data-testid\` attributes to select elements rather than CSS classes, tag names, or text content
   - Avoid hard-coded timeouts both in form of sleep() or timeout: 5000 etc; use proper async patterns (\`waitFor\`, \`findBy*\`, event-based sync) instead and rely on global test configs for timeout settings

2. **Green Phase**: Write MINIMAL code to make the test pass

   - Implement only what's needed for the current failing test
   - No anticipatory coding or extra features
   - Address the specific failure message

3. **Refactor Phase**: Improve code structure while keeping tests green
   - Only allowed when relevant tests are passing
   - Requires proof that tests have been run and are green
   - Applies to BOTH implementation and test code
   - No refactoring with failing tests - fix them first

### Core Violations

1. **Multiple Test Addition**

   - Adding more than one new test at once
   - Exception: Initial test file setup or extracting shared test utilities

2. **Over-Implementation**

   - Code that exceeds what's needed to pass the current failing test
   - Adding untested features, methods, or error handling
   - Implementing multiple methods when test only requires one

3. **Premature Implementation**
   - Adding implementation before a test exists and fails properly
   - Adding implementation without running the test first
   - Refactoring when tests haven't been run or are failing

### Critical Principle: Incremental Development

Each step in TDD should address ONE specific issue:

- Test fails "not defined" ‚Üí Create empty stub/class only
- Test fails "not a function" ‚Üí Add method stub only
- Test fails with assertion ‚Üí Implement minimal logic only

### Optional Pre-Phase: Spike Phase

In rare cases where the problem space, interface, or expected behavior is unclear, a **Spike Phase** may be used **before the Red Phase**.
This phase is **not part of the regular TDD workflow** and must only be applied under exceptional circumstances.

- The goal of a Spike is **exploration and learning**, not implementation.
- The code written during a Spike is **disposable** and **must not** be merged or reused directly.
- Once sufficient understanding is achieved, all spike code is discarded, and normal TDD resumes starting from the **Red Phase**.
- A Spike is justified only when it is impossible to define a meaningful failing test due to technical uncertainty or unknown system behavior.

### General Information

- Sometimes the test output shows as no tests have been run when a new test is failing due to a missing import or constructor. In such cases, allow the agent to create simple stubs. Ask them if they forgot to create a stub if they are stuck.
- It is never allowed to introduce new logic without evidence of relevant failing tests. However, stubs and simple implementation to make imports and test infrastructure work is fine.
- In the refactor phase, it is perfectly fine to refactor both test and implementation code. That said, completely new functionality is not allowed. Types, clean up, abstractions, and helpers are allowed as long as they do not introduce new behavior.
- Adding types, interfaces, or a constant in order to replace magic values is perfectly fine during refactoring.
- Provide the agent with helpful directions so that they do not get stuck when blocking them.
"
`;

exports[`downloads/with-beads > should match snapshot for plan.md 1`] = `
"---
description: Create implementation plan from feature/requirement with PRD-style discovery and TDD acceptance criteria
argument-hint: <feature/requirement description or GitHub issue URL/number>
---

# Plan: PRD-Informed Task Planning for TDD

Create structured implementation plan that bridges product thinking (PRD) with test-driven development.

## General Guidelines

### Output Style

- **Never explicitly mention TDD** in code, comments, commits, PRs, or issues
- Write natural, descriptive code without meta-commentary about the development process
- The code should speak for itself - TDD is the process, not the product

Beads is available for task tracking. Use \`mcp__beads__*\` tools to manage issues (the user interacts via \`bd\` commands).

## Input

$ARGUMENTS

(If no input provided, check conversation context or run \`bd ready\` to see existing work)

## Input Processing

The input can be one of:

1. **GitHub Issue URL** (e.g., \`https://github.com/owner/repo/issues/123\`)
2. **GitHub Issue Number** (e.g., \`#123\` or \`123\`)
3. **Feature Description** (e.g., "Add user authentication")
4. **Empty** - use conversation context

### GitHub Issue Integration

If input looks like a GitHub issue:

**Step 1: Extract Issue Number**

- From URL: extract owner/repo/number
- From number: try to infer repo from git remote
- From branch name: check patterns like \`issue-123\`, \`123-feature\`, \`feature/123\`

**Step 2: Fetch Issue**
Try GitHub MCP first:

- If available: use \`mcp__github__issue_read\` to fetch issue details
- If not available: show message and try \`gh issue view <number>\`

\`\`\`
GitHub MCP not configured!
See: https://github.com/modelcontextprotocol/servers/tree/main/src/github
Trying GitHub CLI fallback...
\`\`\`

**Step 3: Use Issue as Discovery Input**

- Title ‚Üí Feature name
- Description ‚Üí Problem statement and context
- Labels ‚Üí Type/priority hints
- Comments ‚Üí Additional requirements and discussion
- Linked issues ‚Üí Dependencies

Extract from GitHub issue:

- Problem statement and context
- Acceptance criteria (if present)
- Technical notes (if present)
- Related issues/dependencies

## Process

## Discovery Phase

Understand the requirement by asking (use AskUserQuestion if needed):

**Problem Statement**

- What problem does this solve?
- Who experiences this problem?
- What's the current pain point?

**Desired Outcome**

- What should happen after this is built?
- How will users interact with it?
- What does success look like?

**Scope & Constraints**

- What's in scope vs. out of scope?
- Any technical constraints?
- Dependencies on other systems/features?

**Context Check**

- Search codebase for related features/modules
- Check for existing test files that might be relevant

### Create Beads Issues

For each task, create a bd issue with:

\`\`\`bash
bd create "Task title" \\
  --type [feature|bug|task|chore] \\
  --priority [1-3] \\
  --description "Context and what needs to be built" \\
  --design "Technical approach, architecture notes" \\
  --acceptance "Given-When-Then acceptance criteria"
\`\`\`

**Issue Structure Best Practices:**

**Title**: Action-oriented, specific

- ‚úÖ "Add JWT token validation middleware"
- ‚ùå "Authentication stuff"

**Description**: Provide context

- Why this task exists
- How it fits into the larger feature
- Links to related issues/docs

**Design**: Technical approach

- Key interfaces/types needed
- Algorithm or approach
- Libraries or patterns to use
- Known gotchas or considerations

**Acceptance Criteria**: Test-ready scenarios

- Given-When-Then format
- Concrete, verifiable conditions
- Cover main case + edge cases
- Map 1:1 to future tests

**Dependencies**: Link related issues

\`\`\`bash
bd dep add ISSUE-123 ISSUE-456 --type blocks
\`\`\`

### Validation

After creating issues, verify:

- ‚úÖ Each issue has clear acceptance criteria
- ‚úÖ Dependencies are mapped (use \`bd dep add\`)
- ‚úÖ Issues are ordered by implementation sequence
- ‚úÖ First few issues are ready to start (\`bd ready\` shows them)
- ‚úÖ Each issue is small enough for TDD (if too big, break down more)

## Key Principles

**From PRD World:**

- Start with user problems, not solutions
- Define success criteria upfront
- Understand constraints and scope

**From TDD World:**

- Make acceptance criteria test-ready
- Break work into small, testable pieces
- Each task should map to test(s)

### Beads Integration

Use Beads MCP to:

- Track work with \`bd ready\` to find next task
- Create issues with \`bd create "description"\`
- Track dependencies with \`bd dep add\`

See <https://github.com/steveyegge/beads> for more information.

## Integration with Other Commands

- **Before /plan**: Use \`/spike\` if you need technical exploration first
- **After /plan**: Use \`/red\` to start TDD on first task
- **During work**: Use \`bd update\` to add notes/findings back to issues
- **When stuck**: Check \`bd show ISSUE-ID\` to review acceptance criteria
"
`;

exports[`downloads/with-beads > should match snapshot for pr.md 1`] = `
"---
description: Creates a pull request using GitHub MCP
argument-hint: [optional-pr-title-and-description]
---

# Create Pull Request

## General Guidelines

### Output Style

- **Never explicitly mention TDD** in code, comments, commits, PRs, or issues
- Write natural, descriptive code without meta-commentary about the development process
- The code should speak for itself - TDD is the process, not the product

Beads is available for task tracking. Use \`mcp__beads__*\` tools to manage issues (the user interacts via \`bd\` commands).

Create a pull request for the current branch using GitHub MCP tools.

## Workflow

Current branch status:
!\`git status\`

Recent commits:
!\`git log --oneline -5\`

Arguments: $ARGUMENTS

**Process:**

1. **Ensure Branch is Ready**:
   !\`git status\`
   - Commit all changes
   - Push to remote: \`git push origin [branch-name]\`

2. **Create PR**: Create a well-formatted pull request

   Title: conventional commits format, like \`feat(#123): add user authentication\`

   Description template:

   \`\`\`markdown
   <!--
     Are there any relevant issues / PRs / mailing lists discussions?
     Please reference them here.
   -->

   ## References

   - [links to github issues referenced in commit messages]

   ## Summary

   [Brief description of changes]

   ## Test Plan

   - [ ] Tests pass
   - [ ] Manual testing completed
   \`\`\`

3. **Set Base Branch**: Default to main unless specified otherwise

4. **Link Issues**: Reference related issues found in commit messages

## Use GitHub MCP Tools

1. Check current branch and ensure it's pushed
2. Create a well-formatted pull request with proper title and description
3. Set the base branch (default: main)
4. Include relevant issue references if found in commit messages

### Beads Integration

Use Beads MCP to:

- Track work with \`bd ready\` to find next task
- Create issues with \`bd create "description"\`
- Track dependencies with \`bd dep add\`

See <https://github.com/steveyegge/beads> for more information.
"
`;

exports[`downloads/with-beads > should match snapshot for red.md 1`] = `
"---
description: Execute TDD Red Phase - write ONE failing test
argument-hint: [optional additional info]
---

RED PHASE! Apply the below to the info given by user input here:

$ARGUMENTS

## General Guidelines

### Output Style

- **Never explicitly mention TDD** in code, comments, commits, PRs, or issues
- Write natural, descriptive code without meta-commentary about the development process
- The code should speak for itself - TDD is the process, not the product

Beads is available for task tracking. Use \`mcp__beads__*\` tools to manage issues (the user interacts via \`bd\` commands).

(If there was no info above, fallback to:

1. Context of the conversation, if there's an immediate thing
2. \`bd ready\` to see what to work on next and start from there)

## TDD Fundamentals

### The TDD Cycle

The foundation of TDD is the Red-Green-Refactor cycle:

1. **Red Phase**: Write ONE failing test that describes desired behavior

   - The test must fail for the RIGHT reason (not syntax/import errors)
   - Only one test at a time - this is critical for TDD discipline
     - Exception: For browser-level tests or expensive setup (e.g., Storybook \`*.stories.tsx\`), group multiple assertions within a single test block to avoid redundant setup - but only when adding assertions to an existing interaction flow. If new user interactions are required, still create a new test. Split files by category if they exceed ~1000 lines.
   - **Adding a single test to a test file is ALWAYS allowed** - no prior test output needed
   - Starting TDD for a new feature is always valid, even if test output shows unrelated work
   - For DOM-based tests, use \`data-testid\` attributes to select elements rather than CSS classes, tag names, or text content
   - Avoid hard-coded timeouts both in form of sleep() or timeout: 5000 etc; use proper async patterns (\`waitFor\`, \`findBy*\`, event-based sync) instead and rely on global test configs for timeout settings

2. **Green Phase**: Write MINIMAL code to make the test pass

   - Implement only what's needed for the current failing test
   - No anticipatory coding or extra features
   - Address the specific failure message

3. **Refactor Phase**: Improve code structure while keeping tests green
   - Only allowed when relevant tests are passing
   - Requires proof that tests have been run and are green
   - Applies to BOTH implementation and test code
   - No refactoring with failing tests - fix them first

### Core Violations

1. **Multiple Test Addition**

   - Adding more than one new test at once
   - Exception: Initial test file setup or extracting shared test utilities

2. **Over-Implementation**

   - Code that exceeds what's needed to pass the current failing test
   - Adding untested features, methods, or error handling
   - Implementing multiple methods when test only requires one

3. **Premature Implementation**
   - Adding implementation before a test exists and fails properly
   - Adding implementation without running the test first
   - Refactoring when tests haven't been run or are failing

### Critical Principle: Incremental Development

Each step in TDD should address ONE specific issue:

- Test fails "not defined" ‚Üí Create empty stub/class only
- Test fails "not a function" ‚Üí Add method stub only
- Test fails with assertion ‚Üí Implement minimal logic only

### Optional Pre-Phase: Spike Phase

In rare cases where the problem space, interface, or expected behavior is unclear, a **Spike Phase** may be used **before the Red Phase**.
This phase is **not part of the regular TDD workflow** and must only be applied under exceptional circumstances.

- The goal of a Spike is **exploration and learning**, not implementation.
- The code written during a Spike is **disposable** and **must not** be merged or reused directly.
- Once sufficient understanding is achieved, all spike code is discarded, and normal TDD resumes starting from the **Red Phase**.
- A Spike is justified only when it is impossible to define a meaningful failing test due to technical uncertainty or unknown system behavior.

### General Information

- Sometimes the test output shows as no tests have been run when a new test is failing due to a missing import or constructor. In such cases, allow the agent to create simple stubs. Ask them if they forgot to create a stub if they are stuck.
- It is never allowed to introduce new logic without evidence of relevant failing tests. However, stubs and simple implementation to make imports and test infrastructure work is fine.
- In the refactor phase, it is perfectly fine to refactor both test and implementation code. That said, completely new functionality is not allowed. Types, clean up, abstractions, and helpers are allowed as long as they do not introduce new behavior.
- Adding types, interfaces, or a constant in order to replace magic values is perfectly fine during refactoring.
- Provide the agent with helpful directions so that they do not get stuck when blocking them.
"
`;

exports[`downloads/with-beads > should match snapshot for refactor.md 1`] = `
"---
description: Execute TDD Refactor Phase - improve code structure while keeping tests green
argument-hint: <refactoring description>
---

Apply this document (specifically the Refactor phase), to the info given by user input here: $ARGUMENTS

## General Guidelines

### Output Style

- **Never explicitly mention TDD** in code, comments, commits, PRs, or issues
- Write natural, descriptive code without meta-commentary about the development process
- The code should speak for itself - TDD is the process, not the product

Beads is available for task tracking. Use \`mcp__beads__*\` tools to manage issues (the user interacts via \`bd\` commands).

(If there was no info above, fallback to:

1. Context of the conversation, if there's an immediate thing
2. \`bd ready\` to see what to work on next and start from there)

## TDD Fundamentals

### The TDD Cycle

The foundation of TDD is the Red-Green-Refactor cycle:

1. **Red Phase**: Write ONE failing test that describes desired behavior

   - The test must fail for the RIGHT reason (not syntax/import errors)
   - Only one test at a time - this is critical for TDD discipline
     - Exception: For browser-level tests or expensive setup (e.g., Storybook \`*.stories.tsx\`), group multiple assertions within a single test block to avoid redundant setup - but only when adding assertions to an existing interaction flow. If new user interactions are required, still create a new test. Split files by category if they exceed ~1000 lines.
   - **Adding a single test to a test file is ALWAYS allowed** - no prior test output needed
   - Starting TDD for a new feature is always valid, even if test output shows unrelated work
   - For DOM-based tests, use \`data-testid\` attributes to select elements rather than CSS classes, tag names, or text content
   - Avoid hard-coded timeouts both in form of sleep() or timeout: 5000 etc; use proper async patterns (\`waitFor\`, \`findBy*\`, event-based sync) instead and rely on global test configs for timeout settings

2. **Green Phase**: Write MINIMAL code to make the test pass

   - Implement only what's needed for the current failing test
   - No anticipatory coding or extra features
   - Address the specific failure message

3. **Refactor Phase**: Improve code structure while keeping tests green
   - Only allowed when relevant tests are passing
   - Requires proof that tests have been run and are green
   - Applies to BOTH implementation and test code
   - No refactoring with failing tests - fix them first

### Core Violations

1. **Multiple Test Addition**

   - Adding more than one new test at once
   - Exception: Initial test file setup or extracting shared test utilities

2. **Over-Implementation**

   - Code that exceeds what's needed to pass the current failing test
   - Adding untested features, methods, or error handling
   - Implementing multiple methods when test only requires one

3. **Premature Implementation**
   - Adding implementation before a test exists and fails properly
   - Adding implementation without running the test first
   - Refactoring when tests haven't been run or are failing

### Critical Principle: Incremental Development

Each step in TDD should address ONE specific issue:

- Test fails "not defined" ‚Üí Create empty stub/class only
- Test fails "not a function" ‚Üí Add method stub only
- Test fails with assertion ‚Üí Implement minimal logic only

### Optional Pre-Phase: Spike Phase

In rare cases where the problem space, interface, or expected behavior is unclear, a **Spike Phase** may be used **before the Red Phase**.
This phase is **not part of the regular TDD workflow** and must only be applied under exceptional circumstances.

- The goal of a Spike is **exploration and learning**, not implementation.
- The code written during a Spike is **disposable** and **must not** be merged or reused directly.
- Once sufficient understanding is achieved, all spike code is discarded, and normal TDD resumes starting from the **Red Phase**.
- A Spike is justified only when it is impossible to define a meaningful failing test due to technical uncertainty or unknown system behavior.

### General Information

- Sometimes the test output shows as no tests have been run when a new test is failing due to a missing import or constructor. In such cases, allow the agent to create simple stubs. Ask them if they forgot to create a stub if they are stuck.
- It is never allowed to introduce new logic without evidence of relevant failing tests. However, stubs and simple implementation to make imports and test infrastructure work is fine.
- In the refactor phase, it is perfectly fine to refactor both test and implementation code. That said, completely new functionality is not allowed. Types, clean up, abstractions, and helpers are allowed as long as they do not introduce new behavior.
- Adding types, interfaces, or a constant in order to replace magic values is perfectly fine during refactoring.
- Provide the agent with helpful directions so that they do not get stuck when blocking them.

1. **Consistency check** - Look for inconsistent patterns, naming conventions, or structure across the codebase
"
`;

exports[`downloads/with-beads > should match snapshot for ship.md 1`] = `
"---
description: Ship code directly to main - for small, obvious changes that don't need review
argument-hint: [optional-commit-message]
---

# Ship - Direct Merge to Main

## General Guidelines

### Output Style

- **Never explicitly mention TDD** in code, comments, commits, PRs, or issues
- Write natural, descriptive code without meta-commentary about the development process
- The code should speak for itself - TDD is the process, not the product

Beads is available for task tracking. Use \`mcp__beads__*\` tools to manage issues (the user interacts via \`bd\` commands).

**Ship/Show/Ask Pattern - SHIP**

Ship is for small, obvious changes that don't need code review. Examples:

- Typo fixes
- Formatting changes
- Documentation updates
- Obvious bug fixes
- Dependency updates with passing tests

## Prerequisites

Before shipping directly to main:

1. All tests must pass
2. Linter must pass
3. Changes must be small and low-risk
4. CI must be green (if configured)

## Workflow

Current branch status:
!\`git status\`

Recent commits:
!\`git log --oneline -5\`

Arguments: $ARGUMENTS

**Process:**

1. **Verify Change Size**: Check git diff to ensure changes are small and focused
   !\`git diff --stat main\`

2. **Run Tests**: Ensure all tests pass
   !\`npm test\` or !\`yarn test\` or appropriate test command for the project

3. **Run Linter**: Ensure code quality checks pass
   !\`npm run lint\` or !\`yarn lint\` or appropriate lint command (if available)

4. **Safety Check**: Confirm with user that this is truly a ship-worthy change:
   - Is this a small, obvious change?
   - Do all tests pass?
   - Is CI green?

   If ANY of these are "no", suggest using \`/show\` or \`/ask\` instead.

5. **Merge to Main**: If all checks pass and user confirms:

   \`\`\`bash
   git checkout main
   git pull origin main
   git merge --ff-only [feature-branch] || git merge [feature-branch]
   git push origin main
   \`\`\`

6. **Cleanup**: Delete the feature branch

   \`\`\`bash
   git branch -d [feature-branch]
   git push origin --delete [feature-branch]
   \`\`\`

7. **Notify**: Show summary of what was shipped

## Safety Rails

If tests fail, linter fails, or changes are large/complex, STOP and suggest:

- Use \`/show\` for changes that should be seen but don't need approval
- Use \`/ask\` (traditional PR) for complex changes needing discussion

### Beads Integration

Use Beads MCP to:

- Track work with \`bd ready\` to find next task
- Create issues with \`bd create "description"\`
- Track dependencies with \`bd dep add\`

See <https://github.com/steveyegge/beads> for more information.
"
`;

exports[`downloads/with-beads > should match snapshot for show.md 1`] = `
"---
description: Show code to team with auto-merge - for changes that should be visible but don't need approval
argument-hint: [optional-pr-title-and-description]
---

# Show - Visible Merge with Optional Feedback

## General Guidelines

### Output Style

- **Never explicitly mention TDD** in code, comments, commits, PRs, or issues
- Write natural, descriptive code without meta-commentary about the development process
- The code should speak for itself - TDD is the process, not the product

Beads is available for task tracking. Use \`mcp__beads__*\` tools to manage issues (the user interacts via \`bd\` commands).

**Ship/Show/Ask Pattern - SHOW**

Show is for changes that teammates should see, but don't require approval. Examples:

- Refactoring with test coverage
- New features with comprehensive tests
- Performance improvements
- Non-breaking API changes

## Prerequisites

Before using show:

1. All tests must pass
2. Changes should have good test coverage
3. Changes should be non-breaking or backward compatible
4. CI must be green

## Workflow

Current branch status:
!\`git status\`

Recent commits:
!\`git log --oneline -5\`

Arguments: $ARGUMENTS

**Process:**

1. **Verify Quality**: Check that changes meet show criteria
   - Run tests: !\`npm test\` or !\`yarn test\` or appropriate test command
   - Check coverage is maintained or improved
   - Verify no breaking changes

2. **Create Show PR**: Create a PR that will auto-merge after a short window
   - Title: conventional commits format, prefixed with \`[SHOW]\`
   - Description: Clear explanation of what changed and why
   - Add label: "show" or "auto-merge"
   - Set auto-merge if GitHub setting allows

3. **Configure Auto-Merge**:
   - If GitHub Actions is configured, set to auto-merge after CI passes
   - If not, provide instructions to merge after 1-2 hours of visibility
   - Add notice that feedback is welcome but not required

4. **PR Description Template**:

   \`\`\`markdown
   ## üöÄ Show - Auto-merging after CI

   **This is a SHOW PR**: Changes are ready to merge but shared for visibility.
   Feedback welcome but not required. Will auto-merge when CI passes.

   <!--
     References: [link to relevant issues]
   -->

   ### What changed

   [Brief description]

   ### Why

   [Rationale for change]

   ### Test coverage

   - [ ] All tests pass
   - [ ] Coverage maintained/improved
   - [ ] No breaking changes
   \`\`\`

5. **Monitoring**: Check PR status and auto-merge when ready

## Decision Guide

Use **Show** when:

- ‚úÖ Tests are comprehensive
- ‚úÖ Changes are non-breaking
- ‚úÖ You're confident in the approach
- ‚úÖ Team should be aware of the change

Use **/ship** instead if: change is tiny and obvious (typo, formatting)

Use **/ask** instead if: change needs discussion, breaks APIs, or you're uncertain

### Beads Integration

Use Beads MCP to:

- Track work with \`bd ready\` to find next task
- Create issues with \`bd create "description"\`
- Track dependencies with \`bd dep add\`

See <https://github.com/steveyegge/beads> for more information.
"
`;

exports[`downloads/with-beads > should match snapshot for spike.md 1`] = `
"---
description: Execute TDD Spike Phase - exploratory coding to understand problem space before TDD
argument-hint: <exploration description>
---

SPIKE PHASE! Apply the below to the info given by user input here:

$ARGUMENTS

## General Guidelines

### Output Style

- **Never explicitly mention TDD** in code, comments, commits, PRs, or issues
- Write natural, descriptive code without meta-commentary about the development process
- The code should speak for itself - TDD is the process, not the product

Beads is available for task tracking. Use \`mcp__beads__*\` tools to manage issues (the user interacts via \`bd\` commands).

(If there was no info above, fallback to:

1. Context of the conversation, if there's an immediate thing
2. \`bd ready\` to see what to work on next and start from there)

## TDD Fundamentals

### The TDD Cycle

The foundation of TDD is the Red-Green-Refactor cycle:

1. **Red Phase**: Write ONE failing test that describes desired behavior

   - The test must fail for the RIGHT reason (not syntax/import errors)
   - Only one test at a time - this is critical for TDD discipline
     - Exception: For browser-level tests or expensive setup (e.g., Storybook \`*.stories.tsx\`), group multiple assertions within a single test block to avoid redundant setup - but only when adding assertions to an existing interaction flow. If new user interactions are required, still create a new test. Split files by category if they exceed ~1000 lines.
   - **Adding a single test to a test file is ALWAYS allowed** - no prior test output needed
   - Starting TDD for a new feature is always valid, even if test output shows unrelated work
   - For DOM-based tests, use \`data-testid\` attributes to select elements rather than CSS classes, tag names, or text content
   - Avoid hard-coded timeouts both in form of sleep() or timeout: 5000 etc; use proper async patterns (\`waitFor\`, \`findBy*\`, event-based sync) instead and rely on global test configs for timeout settings

2. **Green Phase**: Write MINIMAL code to make the test pass

   - Implement only what's needed for the current failing test
   - No anticipatory coding or extra features
   - Address the specific failure message

3. **Refactor Phase**: Improve code structure while keeping tests green
   - Only allowed when relevant tests are passing
   - Requires proof that tests have been run and are green
   - Applies to BOTH implementation and test code
   - No refactoring with failing tests - fix them first

### Core Violations

1. **Multiple Test Addition**

   - Adding more than one new test at once
   - Exception: Initial test file setup or extracting shared test utilities

2. **Over-Implementation**

   - Code that exceeds what's needed to pass the current failing test
   - Adding untested features, methods, or error handling
   - Implementing multiple methods when test only requires one

3. **Premature Implementation**
   - Adding implementation before a test exists and fails properly
   - Adding implementation without running the test first
   - Refactoring when tests haven't been run or are failing

### Critical Principle: Incremental Development

Each step in TDD should address ONE specific issue:

- Test fails "not defined" ‚Üí Create empty stub/class only
- Test fails "not a function" ‚Üí Add method stub only
- Test fails with assertion ‚Üí Implement minimal logic only

### Optional Pre-Phase: Spike Phase

In rare cases where the problem space, interface, or expected behavior is unclear, a **Spike Phase** may be used **before the Red Phase**.
This phase is **not part of the regular TDD workflow** and must only be applied under exceptional circumstances.

- The goal of a Spike is **exploration and learning**, not implementation.
- The code written during a Spike is **disposable** and **must not** be merged or reused directly.
- Once sufficient understanding is achieved, all spike code is discarded, and normal TDD resumes starting from the **Red Phase**.
- A Spike is justified only when it is impossible to define a meaningful failing test due to technical uncertainty or unknown system behavior.

### General Information

- Sometimes the test output shows as no tests have been run when a new test is failing due to a missing import or constructor. In such cases, allow the agent to create simple stubs. Ask them if they forgot to create a stub if they are stuck.
- It is never allowed to introduce new logic without evidence of relevant failing tests. However, stubs and simple implementation to make imports and test infrastructure work is fine.
- In the refactor phase, it is perfectly fine to refactor both test and implementation code. That said, completely new functionality is not allowed. Types, clean up, abstractions, and helpers are allowed as long as they do not introduce new behavior.
- Adding types, interfaces, or a constant in order to replace magic values is perfectly fine during refactoring.
- Provide the agent with helpful directions so that they do not get stuck when blocking them.
"
`;

exports[`downloads/with-beads > should match snapshot for summarize.md 1`] = `
"---
description: Summarize conversation progress and next steps
argument-hint: [optional additional info]
---

## General Guidelines

### Output Style

- **Never explicitly mention TDD** in code, comments, commits, PRs, or issues
- Write natural, descriptive code without meta-commentary about the development process
- The code should speak for itself - TDD is the process, not the product

Beads is available for task tracking. Use \`mcp__beads__*\` tools to manage issues (the user interacts via \`bd\` commands).

Create a concise summary of the current conversation suitable for transferring context to a new conversation.

Additional info: $ARGUMENTS

## Summary Structure

Provide a summary with these sections:

### What We Did

- Key accomplishments and changes made
- Important decisions or discoveries
- Files created, modified, or analyzed

### What We're Doing Next

- Immediate next steps
- Pending tasks or work in progress
- Goals or objectives to continue

### Blockers & User Input Needed

- Any issues requiring user intervention
- Decisions that need to be made
- Missing information or clarifications needed

## Output Format

Keep the summary concise and actionable - suitable for pasting into a new conversation to quickly restore context without needing the full conversation history.

## Beads Integration

If Beads MCP is available, check for task tracking status and ask if the user wants to:

1. Review current task status
2. Update task states based on conversation progress
3. Include Beads context in the summary

Use AskUserQuestion to confirm Beads integration preferences.
"
`;

exports[`downloads/with-beads > should match snapshot for tdd.md 1`] = `
"---
description: Remind agent about TDD approach and continue conversation
argument-hint: [optional-response-to-last-message]
---

# TDD Reminder

## General Guidelines

### Output Style

- **Never explicitly mention TDD** in code, comments, commits, PRs, or issues
- Write natural, descriptive code without meta-commentary about the development process
- The code should speak for itself - TDD is the process, not the product

Beads is available for task tracking. Use \`mcp__beads__*\` tools to manage issues (the user interacts via \`bd\` commands).

## TDD Fundamentals

### The TDD Cycle

The foundation of TDD is the Red-Green-Refactor cycle:

1. **Red Phase**: Write ONE failing test that describes desired behavior

   - The test must fail for the RIGHT reason (not syntax/import errors)
   - Only one test at a time - this is critical for TDD discipline
     - Exception: For browser-level tests or expensive setup (e.g., Storybook \`*.stories.tsx\`), group multiple assertions within a single test block to avoid redundant setup - but only when adding assertions to an existing interaction flow. If new user interactions are required, still create a new test. Split files by category if they exceed ~1000 lines.
   - **Adding a single test to a test file is ALWAYS allowed** - no prior test output needed
   - Starting TDD for a new feature is always valid, even if test output shows unrelated work
   - For DOM-based tests, use \`data-testid\` attributes to select elements rather than CSS classes, tag names, or text content
   - Avoid hard-coded timeouts both in form of sleep() or timeout: 5000 etc; use proper async patterns (\`waitFor\`, \`findBy*\`, event-based sync) instead and rely on global test configs for timeout settings

2. **Green Phase**: Write MINIMAL code to make the test pass

   - Implement only what's needed for the current failing test
   - No anticipatory coding or extra features
   - Address the specific failure message

3. **Refactor Phase**: Improve code structure while keeping tests green
   - Only allowed when relevant tests are passing
   - Requires proof that tests have been run and are green
   - Applies to BOTH implementation and test code
   - No refactoring with failing tests - fix them first

### Core Violations

1. **Multiple Test Addition**

   - Adding more than one new test at once
   - Exception: Initial test file setup or extracting shared test utilities

2. **Over-Implementation**

   - Code that exceeds what's needed to pass the current failing test
   - Adding untested features, methods, or error handling
   - Implementing multiple methods when test only requires one

3. **Premature Implementation**
   - Adding implementation before a test exists and fails properly
   - Adding implementation without running the test first
   - Refactoring when tests haven't been run or are failing

### Critical Principle: Incremental Development

Each step in TDD should address ONE specific issue:

- Test fails "not defined" ‚Üí Create empty stub/class only
- Test fails "not a function" ‚Üí Add method stub only
- Test fails with assertion ‚Üí Implement minimal logic only

### Optional Pre-Phase: Spike Phase

In rare cases where the problem space, interface, or expected behavior is unclear, a **Spike Phase** may be used **before the Red Phase**.
This phase is **not part of the regular TDD workflow** and must only be applied under exceptional circumstances.

- The goal of a Spike is **exploration and learning**, not implementation.
- The code written during a Spike is **disposable** and **must not** be merged or reused directly.
- Once sufficient understanding is achieved, all spike code is discarded, and normal TDD resumes starting from the **Red Phase**.
- A Spike is justified only when it is impossible to define a meaningful failing test due to technical uncertainty or unknown system behavior.

### General Information

- Sometimes the test output shows as no tests have been run when a new test is failing due to a missing import or constructor. In such cases, allow the agent to create simple stubs. Ask them if they forgot to create a stub if they are stuck.
- It is never allowed to introduce new logic without evidence of relevant failing tests. However, stubs and simple implementation to make imports and test infrastructure work is fine.
- In the refactor phase, it is perfectly fine to refactor both test and implementation code. That said, completely new functionality is not allowed. Types, clean up, abstractions, and helpers are allowed as long as they do not introduce new behavior.
- Adding types, interfaces, or a constant in order to replace magic values is perfectly fine during refactoring.
- Provide the agent with helpful directions so that they do not get stuck when blocking them.

## Continue Conversation

User response to the last message: $ARGUMENTS

Please continue with TDD approach based on the above response.
"
`;

exports[`downloads/with-beads > should match snapshot for worktree-add.md 1`] = `
"---
description: Add a new git worktree from branch name or issue URL, copy settings, install deps, and open in current IDE
argument-hint: <branch-name-or-issue-url> [optional-base-branch]
---

# Git Worktree Setup

## General Guidelines

### Output Style

- **Never explicitly mention TDD** in code, comments, commits, PRs, or issues
- Write natural, descriptive code without meta-commentary about the development process
- The code should speak for itself - TDD is the process, not the product

Beads is available for task tracking. Use \`mcp__beads__*\` tools to manage issues (the user interacts via \`bd\` commands).

Create a new git worktree for branch: $ARGUMENTS

<current_state>
Current branch: \`git branch --show-current\`
Current worktrees: \`git worktree list\`
Remote branches: \`git branch -r\`
Uncommitted changes: \`git status --short\`
</current_state>

<execution_steps>
<step_0>
  <description>Ask user for setup mode</description>
  <prompt>
    <message>How would you like to set up the worktree?</message>
    <options>
      <option value="quick">
        <label>Quick</label>
        <description>Just create the worktree (skip deps, settings, IDE)</description>
      </option>
      <option value="full">
        <label>Full setup</label>
        <description>Install dependencies, copy settings, open in IDE</description>
      </option>
    </options>
  </prompt>
  <set_variable>$SETUP_MODE = user selection ("quick" or "full")</set_variable>
  <purpose>Allow quick worktree creation when user just needs the branch</purpose>
</step_0>

<step_0b>
  <description>Detect git hosting provider and available tools (only needed if argument is an issue URL)</description>
  <condition>Only run this step if first argument looks like a git hosting URL</condition>
<detect_provider>
  <check_remote_url>git remote get-url origin</check_remote_url>
  <identify_host>
    - github.com ‚Üí GitHub
    - gitlab.com ‚Üí GitLab
    - bitbucket.org ‚Üí Bitbucket
    - Other ‚Üí Ask user
  </identify_host>
</detect_provider>
<check_available_tools>
  <list_mcp_servers>Check which git-hosting MCP servers are available (github, gitlab, etc.)</list_mcp_servers>
  <check_cli>Check if gh/glab CLI is available as fallback</check_cli>
</check_available_tools>
<select_tool>
  <if_single_mcp>If only one relevant MCP available, confirm with user</if_single_mcp>
  <if_multiple>Let user choose which tool to use</if_multiple>
  <if_told_earlier>If user specified tool earlier in conversation, use that without asking again</if_told_earlier>
  <store_as>$GIT_HOST_TOOL (e.g., "github_mcp", "gitlab_mcp", "gh_cli")</store_as>
</select_tool>

  <purpose>Detect git hosting provider and select appropriate tool for issue lookup</purpose>
</step_0b>

  <step_1>
    <description>Detect current IDE environment</description>
    <condition>Only if $SETUP_MODE is "full"</condition>
    <detection_methods>
      <method_1>
        <tool>mcp__ide__getDiagnostics</tool>
        <vs_code_insiders>Check for paths containing "Code - Insiders"</vs_code_insiders>
        <vs_code>Check for paths containing "Code/" or "Code.app"</vs_code>
        <cursor>Check for paths containing "Cursor"</cursor>
        <zed>Check for paths containing "Zed"</zed>
      </method_1>
      <method_2>
        <fallback_detection>Use which command to find available IDEs</fallback_detection>
        <commands>which code-insiders code zed cursor</commands>
        <priority_order>code-insiders > cursor > zed > code</priority_order>
      </method_2>
    </detection_methods>
    <set_variables>
      <ide_command>Detected command (code-insiders|code|zed|cursor)</ide_command>
      <ide_name>Human-readable name</ide_name>
      <supports_tasks>true for VS Code variants, false for others</supports_tasks>
    </set_variables>
    <purpose>Automatically detect which IDE to use for opening the new worktree</purpose>
  </step_1>

  <step_2>
    <description>Determine default branch and parse arguments</description>
    <find_default_branch>
      <command>git symbolic-ref refs/remotes/origin/HEAD | sed 's@^refs/remotes/origin/@@'</command>
      <fallback>git remote show origin | grep 'HEAD branch' | cut -d: -f2 | tr -d ' '</fallback>
      <store_as>$DEFAULT_BRANCH (typically "main" or "master")</store_as>
    </find_default_branch>
    <input>The user-provided arguments</input>
    <expected_format>branch-name-or-issue-url [optional-base-branch]</expected_format>
    <example>fix/issue-123-main-content-area-visually-clipped main</example>
    <example_issue_url>https://github.com/owner/project/issues/123 main</example_issue_url>
    <base_branch>Use provided base branch, or $DEFAULT_BRANCH if not specified</base_branch>
  </step_2>

  <step_2_5>
    <description>Handle issue URLs from git hosting provider</description>
    <condition>If first argument matches issue URL pattern (detected in step_0)</condition>
    <url_detection>
      <github>Check if argument contains "github.com" and "/issues/"</github>
      <gitlab>Check if argument contains "gitlab.com" and "/-/issues/"</gitlab>
      <bitbucket>Check if argument contains "bitbucket.org" and "/issues/"</bitbucket>
    </url_detection>
    <url_parsing>
      <github_pattern><https://github.com/{owner}/{repo}/issues/{issue_number}></github_pattern>
      <gitlab_pattern><https://gitlab.com/{owner}/{repo}/-/issues/{issue_number}></gitlab_pattern>
      <bitbucket_pattern><https://bitbucket.org/{owner}/{repo}/issues/{issue_number}></bitbucket_pattern>
      <extract>owner, repo, issue_number from URL</extract>
    </url_parsing>
    <fetch_issue_details>
      <tool>Use $GIT_HOST_TOOL from step_0</tool>
      <method>get issue details</method>
      <parameters>owner, repo, issue_number</parameters>
    </fetch_issue_details>
    <generate_branch_name>
      <determine_type>Analyze issue title/labels to determine type (feat/fix/refactor/chore)</determine_type>
      <format>{type}/issue-{issue_number}-{kebab-case-title}</format>
      <kebab_case>Convert title to lowercase, replace spaces/special chars with hyphens</kebab_case>
      <sanitization>
        <rule>Always use lowercase for branch names</rule>
        <rule>Replace # with - (hash symbol not allowed in git branch names)</rule>
        <rule>Remove or replace other special characters: @, $, %, ^, &, *, (, ), [, ], {, }, \\, |, ;, :, ", ', <, >, ?, /, ~, \`</rule>
        <rule>Replace multiple consecutive hyphens with single hyphen</rule>
        <rule>Trim leading/trailing hyphens</rule>
      </sanitization>
      <truncate>Limit total branch name to reasonable length (~60 chars)</truncate>
    </generate_branch_name>
    <user_confirmation>
      <display>Show generated branch name and ask for confirmation</display>
      <options>"Yes, proceed" or "No, exit" or "Edit branch name"</options>
      <if_no>Exit command gracefully</if_no>
      <if_edit>Allow user to modify the branch name</if_edit>
      <if_yes>Continue with generated/modified branch name</if_yes>
    </user_confirmation>
    <examples>
      <input>https://github.com/owner/project/issues/456</input>
      <title>"Fix duplicate items in list view"</title>
      <generated>fix/issue-456-duplicate-items-in-list-view</generated>
    </examples>
  </step_2_5>

  <step_3>
    <description>Handle uncommitted changes if any exist</description>
    <condition>If git status --short output is not empty (has uncommitted changes)</condition>
    <prompt>
      <message>You have uncommitted changes. Move them to the new branch?</message>
      <options>
        <option value="yes">
          <label>Yes</label>
          <description>Stash changes and apply them in the new worktree</description>
        </option>
        <option value="no">
          <label>No</label>
          <description>Leave changes in current branch</description>
        </option>
      </options>
    </prompt>
    <if_yes>
      <command>git add -A && git stash push -m "Worktree switch: Moving changes to \${branch_name}"</command>
      <set_variable>$STASH_CREATED = true</set_variable>
    </if_yes>
    <if_no>
      <set_variable>$STASH_CREATED = false</set_variable>
    </if_no>
    <purpose>Let user decide whether to move work in progress to new branch</purpose>
  </step_3>

  <step_4>
    <description>Determine worktree parent directory</description>
    <check_if_in_worktree>git rev-parse --is-inside-work-tree && git worktree list --porcelain | grep "$(git rev-parse --show-toplevel)"</check_if_in_worktree>
    <set_parent_path>
      <if_main_worktree>Set parent_path=".."</if_main_worktree>
      <if_secondary_worktree>Set parent_path="../.." (need to go up two levels)</if_secondary_worktree>
    </set_parent_path>
    <purpose>Correctly determine where to create new worktree regardless of current location</purpose>
    <note>This handles both main worktree and secondary worktree scenarios</note>
  </step_4>

  <step_5>
    <description>Fetch latest changes from remote</description>
    <command>git fetch origin</command>
    <purpose>Ensure we have the latest remote branches and default branch state</purpose>
    <note>This ensures new worktrees are created from the most recent default branch</note>
  </step_5>

  <step_6>
    <description>Check if branch exists on remote</description>
    <command>git branch -r | grep "origin/\${branch_name}"</command>
    <decision>
      <if_exists>Branch exists on remote - will checkout existing branch</if_exists>
      <if_not_exists>Branch does not exist - will create new branch from base</if_not_exists>
    </decision>
  </step_6>

  <step_7>
    <description>Create the worktree</description>
    <option_a_new_branch>
      <condition>Remote branch does NOT exist</condition>
      <command>git worktree add \${parent_path}/\${branch_name} -b \${branch_name} \${base_branch}</command>
      <example>git worktree add ../fix/issue-123-main-content-area-visually-clipped -b fix/issue-123-main-content-area-visually-clipped main</example>
    </option_a_new_branch>
    <option_b_existing_branch>
      <condition>Remote branch EXISTS</condition>
      <command>git worktree add \${parent_path}/\${branch_name} \${branch_name}</command>
      <example>git worktree add ../fix/issue-123-main-content-area-visually-clipped fix/issue-123-main-content-area-visually-clipped</example>
    </option_b_existing_branch>
  </step_7>

  <step_7b>
    <description>Set up remote tracking for new branch</description>
    <condition>Only if new branch was created (option_a from step_7)</condition>
    <working_directory>\${parent_path}/\${branch_name}</working_directory>
    <command>cd \${parent_path}/\${branch_name} && git push -u origin \${branch_name}</command>
    <purpose>Establish remote tracking so git status shows ahead/behind and git push/pull work without specifying remote</purpose>
    <note>This creates the remote branch and sets upstream tracking in one step</note>
  </step_7b>

  <step_7c>
    <description>Quick mode completion</description>
    <condition>Only if $SETUP_MODE is "quick"</condition>
    <message>Worktree created at: \${parent_path}/\${branch_name}</message>
    <suggested_next_steps>
      <intro>You can now:</intro>
      <suggestion priority="1">Open in VS Code: \`code \${parent_path}/\${branch_name}\`</suggestion>
      <suggestion priority="2">Open in Cursor: \`cursor \${parent_path}/\${branch_name}\`</suggestion>
      <suggestion priority="3">Navigate to it: \`cd \${parent_path}/\${branch_name}\`</suggestion>
      <suggestion priority="4">Install dependencies: \`cd \${parent_path}/\${branch_name} && pnpm install\`</suggestion>
    </suggested_next_steps>
    <action>STOP here - do not continue to remaining steps</action>
  </step_7c>

  <step_8>
    <description>Copy Claude settings to new worktree</description>
    <condition>Only if $SETUP_MODE is "full"</condition>
    <source>.claude/settings.local.json</source>
    <destination>\${parent_path}/\${branch_name}/.claude/settings.local.json</destination>
    <command>cp -r .claude/settings.local.json \${parent_path}/\${branch_name}/.claude/settings.local.json</command>
    <purpose>Preserve all permission settings and configurations</purpose>
  </step_8>

  <step_9>
    <description>Copy .env.local files to new worktree</description>
    <condition>Only if $SETUP_MODE is "full"</condition>
    <search_command>find . -name ".env.local" -type f</search_command>
    <copy_logic>For each .env.local file found, copy to corresponding location in new worktree</copy_logic>
    <common_locations>
      - app/.env.local
      - packages/*/.env.local
      - (any other .env.local files found)
    </common_locations>
    <copy_command>find . -name ".env.local" -type f -exec sh -c 'mkdir -p "$(dirname "\${parent_path}/\${branch_name}/$1")" && cp "$1" "\${parent_path}/\${branch_name}/$1"'_ {} \\;</copy_command>
    <purpose>Preserve local environment configurations for development</purpose>
    <note>Only copies files that exist; ignores missing ones</note>
  </step_9>

  <step_10>
    <description>Create IDE-specific configuration (conditional)</description>
    <condition>Only if $SETUP_MODE is "full" AND supports_tasks is true (VS Code variants)</condition>
    <vs_code_tasks>
      <create_directory>mkdir -p \${parent_path}/\${branch_name}/.vscode</create_directory>
      <create_file_command>cat > \${parent_path}/\${branch_name}/.vscode/tasks.json << 'EOF'
{
  "version": "2.0.0",
  "tasks": [
    {
      "label": "Auto start Claude",
      "type": "shell",
      "command": "claude",
      "runOptions": {
        "runOn": "folderOpen"
      },
      "presentation": {
        "echo": false,
        "reveal": "always",
        "focus": true,
        "panel": "new"
      }
    }
  ]
}
EOF</create_file_command>
    </vs_code_tasks>
    <purpose>Create auto-start Claude task for VS Code variants on folder open</purpose>
    <note>Only creates for VS Code variants (code, code-insiders, cursor)</note>
    <skip_message>Skipping IDE-specific config for non-VS Code IDEs</skip_message>
  </step_10>

  <step_11>
    <description>Install dependencies in new worktree</description>
    <condition>Only if $SETUP_MODE is "full"</condition>
    <working_directory>\${parent_path}/\${branch_name}</working_directory>
    <command>cd \${parent_path}/\${branch_name} && pnpm install</command>
    <purpose>Ensure all node_modules are installed for the new worktree</purpose>
  </step_11>

  <step_12>
    <description>Apply stashed changes to new worktree (if stash was created)</description>
    <condition>Only if $SETUP_MODE is "full" AND $STASH_CREATED is true</condition>
    <working_directory>\${parent_path}/\${branch_name}</working_directory>
    <command>cd \${parent_path}/\${branch_name} && git stash pop</command>
    <purpose>Restore uncommitted work-in-progress to the new worktree branch</purpose>
    <note>This moves your uncommitted changes to the new branch where you'll continue working</note>
  </step_12>

  <step_13>
    <description>Open detected IDE in new worktree</description>
    <condition>Only if $SETUP_MODE is "full"</condition>
    <command>\${ide_command} \${parent_path}/\${branch_name}</command>
    <ide_specific_behavior>
      <vs_code_variants>Opens folder in VS Code/Insiders/Cursor with tasks.json auto-starting Claude</vs_code_variants>
      <zed>Opens folder in Zed editor</zed>
      <other>Uses detected IDE command to open folder</other>
    </ide_specific_behavior>
    <purpose>Launch development environment for the new worktree using detected IDE</purpose>
    <confirmation_message>Opening worktree in \${ide_name}</confirmation_message>
  </step_13>
</execution_steps>

<important_notes>

- Offers Quick or Full setup mode - Quick just creates the worktree, Full does everything
- Automatically detects and uses your current IDE (VS Code, VS Code Insiders, Cursor, Zed, etc.) in Full mode
- Creates VS Code-specific tasks.json only for VS Code variants (auto-starts Claude on folder open)
- Branch names with slashes (feat/, fix/, etc.) are fully supported
- The worktree directory path will match the full branch name including slashes
- Settings are copied to maintain the same permissions across worktrees
- Environment files (.env.local) are copied to preserve local configurations
- Each worktree has its own node_modules installation
- Uncommitted changes are automatically stashed and moved to the new worktree
- Your work-in-progress seamlessly transfers to the new branch
- IDE detection fallback: checks available editors and uses priority order
- New branches are automatically pushed with \`-u\` to set up remote tracking

Limitations:

- Assumes remote is named "origin" (most common convention)
- Supports macOS and Linux only (no Windows support)
- Requires MCP server or CLI for git hosting provider when using issue URLs (GitHub, GitLab, etc.)
- Dependency install command is pnpm (modify for npm/yarn if needed)
</important_notes>
"
`;

exports[`downloads/with-beads > should match snapshot for worktree-cleanup.md 1`] = `
"---
description: Clean up merged worktrees by verifying PR/issue status, consolidating settings, and removing stale worktrees
argument-hint: (no arguments)
---

# Worktree Cleanup

## General Guidelines

### Output Style

- **Never explicitly mention TDD** in code, comments, commits, PRs, or issues
- Write natural, descriptive code without meta-commentary about the development process
- The code should speak for itself - TDD is the process, not the product

Beads is available for task tracking. Use \`mcp__beads__*\` tools to manage issues (the user interacts via \`bd\` commands).

Clean up merged worktrees by finding the oldest merged branch, consolidating settings, and removing stale worktrees.

Additional info: $ARGUMENTS

<current_state>
Current branch: \`git branch --show-current\`
Current worktrees: \`git worktree list\`
</current_state>

<execution_steps>
<step_0>
  <description>Detect git hosting provider and available tools</description>
<detect_provider>
  <check_remote_url>git remote get-url origin</check_remote_url>
  <identify_host>
    - github.com ‚Üí GitHub
    - gitlab.com ‚Üí GitLab
    - bitbucket.org ‚Üí Bitbucket
    - Other ‚Üí Ask user
  </identify_host>
</detect_provider>
<check_available_tools>
  <list_mcp_servers>Check which git-hosting MCP servers are available (github, gitlab, etc.)</list_mcp_servers>
  <check_cli>Check if gh/glab CLI is available as fallback</check_cli>
</check_available_tools>
<select_tool>
  <if_single_mcp>If only one relevant MCP available, confirm with user</if_single_mcp>
  <if_multiple>Let user choose which tool to use</if_multiple>
  <if_told_earlier>If user specified tool earlier in conversation, use that without asking again</if_told_earlier>
  <store_as>$GIT_HOST_TOOL (e.g., "github_mcp", "gitlab_mcp", "gh_cli")</store_as>
</select_tool>

  <purpose>Detect git hosting provider and select appropriate tool for PR verification</purpose>
</step_0>

  <step_1>
    <description>Determine default branch and verify we're on it</description>
    <find_default_branch>
      <command>git symbolic-ref refs/remotes/origin/HEAD | sed 's@^refs/remotes/origin/@@'</command>
      <fallback>git remote show origin | grep 'HEAD branch' | cut -d: -f2 | tr -d ' '</fallback>
      <store_as>$DEFAULT_BRANCH (typically "main" or "master")</store_as>
    </find_default_branch>
    <check_current_branch>git branch --show-current</check_current_branch>
    <verify>Current branch must equal $DEFAULT_BRANCH</verify>
    <error_if_not_default>Exit with error: "This command must be run from the default branch ($DEFAULT_BRANCH)"</error_if_not_default>
    <purpose>Ensure we're consolidating to the default branch worktree</purpose>
  </step_1>

  <step_2>
    <description>Get list of all worktrees</description>
    <command>git worktree list --porcelain</command>
    <parse_output>Extract worktree paths and branch names</parse_output>
    <exclude_default>Filter out the default branch worktree from cleanup candidates</exclude_default>
    <purpose>Identify all worktrees that could potentially be cleaned up</purpose>
  </step_2>

  <step_3>
    <description>Find oldest worktree by directory age</description>
    <get_worktree_ages>
      <detect_platform>uname -s (returns "Darwin" for macOS, "Linux" for Linux)</detect_platform>
      <command_macos>git worktree list | grep -v "\\[$DEFAULT_BRANCH\\]" | awk '{print $1}' > /tmp/worktrees-$$.txt && while IFS= read -r path; do echo "$(/usr/bin/stat -f '%Sm' -t '%Y-%m-%d %H:%M' "$path" 2>/dev/null)|$path"; done < /tmp/worktrees-$$.txt | sort; rm -f /tmp/worktrees-$$.txt</command_macos>
      <command_linux>git worktree list | grep -v "\\[$DEFAULT_BRANCH\\]" | awk '{print $1}' > /tmp/worktrees-$$.txt && while IFS= read -r path; do echo "$(stat -c '%y' "$path" 2>/dev/null | cut -d. -f1)|$path"; done < /tmp/worktrees-$$.txt | sort; rm -f /tmp/worktrees-$$.txt</command_linux>
      <purpose>List all worktrees sorted by directory modification time (oldest first)</purpose>
      <critical_notes>
        - Replace $DEFAULT_BRANCH with value from step_1 (e.g., "main" or "master")
        - grep "\\[branch\\]" matches branch name in brackets, not paths containing the word
        - Temp file approach avoids subshell parsing issues with piped while-loops
        - /usr/bin/stat on macOS avoids homebrew stat conflicts
      </critical_notes>
      <expected_output_format>YYYY-MM-DD HH:MM|/full/path/to/worktree (oldest first)</expected_output_format>
    </get_worktree_ages>
    <filter_recent>
      <exclude_new>For worktrees created within the last 24 hours, let user know that this worktree might not be worth cleaning</exclude_new>
      <get_current_time>date +"%Y-%m-%d %H:%M"</get_current_time>
    </filter_recent>
    <select_oldest>
      <extract_branch_name>Parse branch name from oldest worktree path</extract_branch_name>
      <important_note>DO NOT use "git branch --merged" to check merge status - it's unreliable</important_note>
      <proceed_to_pr_check>Move directly to step 4 to verify PR merge status instead</proceed_to_pr_check>
    </select_oldest>
    <purpose>Identify oldest worktree candidate - actual merge verification happens via PR/MR in next step</purpose>
  </step_3>

  <step_4>
    <description>Verify PR/MR merge status (primary merge verification)</description>
    <determine_repo>
      <check_remote>git remote get-url origin</check_remote>
      <parse_repo>Extract owner/repo from remote URL</parse_repo>
    </determine_repo>
    <search_pr>
      <tool>Use $GIT_HOST_TOOL from step_0 (e.g., mcp__github__search_pull_requests, mcp__gitlab__*, or gh CLI)</tool>
      <query>Find PRs/MRs where head={branch_name} and base=$DEFAULT_BRANCH</query>
      <purpose>Find PR/MR for this branch targeting default branch</purpose>
      <important>This is the PRIMARY way to verify if a branch was merged - NOT git commands</important>
    </search_pr>
    <verify_pr_merged>
      <if_pr_found>
        <get_pr_details>Use $GIT_HOST_TOOL to get full PR/MR info</get_pr_details>
        <confirm_merged>Verify PR/MR state is "closed"/"merged" AND merged_at is not null AND base is "$DEFAULT_BRANCH"</confirm_merged>
        <extract_issue_number>Look for issue references in PR title/body (e.g., #123, owner/repo#123)</extract_issue_number>
        <if_merged>Proceed with cleanup - this branch was definitively merged to default branch</if_merged>
        <if_not_merged>
          <skip_worktree>This worktree is NOT merged - continue to next oldest worktree</skip_worktree>
          <repeat_from_step_3>Go back and find the next oldest worktree to check</repeat_from_step_3>
        </if_not_merged>
      </if_pr_found>
      <if_no_pr>
        <skip_worktree>No PR found - this branch was likely never submitted for review</skip_worktree>
        <continue_to_next>Continue checking next oldest worktree</continue_to_next>
      </if_no_pr>
    </verify_pr_merged>
    <purpose>Use PR/MR status as the authoritative source for merge verification instead of unreliable git commands</purpose>
  </step_4>

  <step_4_5>
    <description>Check and close related issue</description>
    <if_issue_found>
      <get_issue_details>
        <tool>Use $GIT_HOST_TOOL to read issue details</tool>
        <extract_repo>From issue reference (main-repo vs cross-repo)</extract_repo>
      </get_issue_details>
      <check_issue_state>
        <if_open>
          <ask_close>Ask user: "Related issue #{number} is still open. Should I close it? (y/N)"</ask_close>
          <if_yes_close>
            <add_closing_comment>
              <tool>Use $GIT_HOST_TOOL to add comment</tool>
              <body_template>Closing this issue as branch {branch_name} was merged to {default_branch} on {merge_date} via PR/MR #{pr_number}.</body_template>
              <get_merge_date>Extract merge date from PR/MR details</get_merge_date>
              <get_pr_number>Use PR/MR number from search results</get_pr_number>
            </add_closing_comment>
            <close_issue>
              <tool>Use $GIT_HOST_TOOL to close issue</tool>
              <state>closed</state>
              <state_reason>completed</state_reason>
            </close_issue>
          </if_yes_close>
        </if_open>
        <if_closed>Inform user issue is already closed</if_closed>
      </check_issue_state>
    </if_issue_found>
    <if_no_issue>Continue without issue management</if_no_issue>
    <purpose>Ensure proper issue lifecycle management</purpose>
  </step_4_5>

  <step_5>
    <description>Check if worktree is locked</description>
    <check_command>git worktree list --porcelain | grep -A5 "worktree {path}" | grep "locked"</check_command>
    <if_locked>
      <unlock_command>git worktree unlock {path}</unlock_command>
      <notify_user>Inform user that worktree was unlocked</notify_user>
    </if_locked>
    <purpose>Unlock worktree if it was locked for tracking purposes</purpose>
  </step_5>

  <step_6>
    <description>Analyze Claude settings differences</description>
    <read_main_settings>.claude/settings.local.json</read_main_settings>
    <read_worktree_settings>{worktree_path}/.claude/settings.local.json</read_worktree_settings>
    <compare_allow_lists>
      <extract_main_allows>Extract "allow" array from main settings</extract_main_allows>
      <extract_worktree_allows>Extract "allow" array from worktree settings</extract_worktree_allows>
      <find_differences>Identify entries in worktree that are not in main</find_differences>
    </compare_allow_lists>
    <filter_suggestions>
      <include_filesystem>Read permissions for filesystem paths</include_filesystem>
      <exclude_intrusive>Exclude bash commands, write permissions, etc.</exclude_intrusive>
      <focus_user_specific>Include only user-specific, non-disruptive entries</focus_user_specific>
    </filter_suggestions>
    <purpose>Identify useful settings to consolidate before cleanup</purpose>
  </step_6>

  <step_7>
    <description>Suggest settings consolidation</description>
    <if_differences_found>
      <display_suggestions>Show filtered differences to user</display_suggestions>
      <ask_confirmation>Ask user which entries to add to main settings</ask_confirmation>
      <apply_changes>Update main .claude/settings.local.json with selected entries</apply_changes>
    </if_differences_found>
    <if_no_differences>Inform user no settings need consolidation</if_no_differences>
    <purpose>Preserve useful development settings before removing worktree</purpose>
  </step_7>

  <step_8>
    <description>Final cleanup confirmation</description>
    <summary>
      <display_worktree>Show worktree path and branch name</display_worktree>
      <show_pr_status>Show merged PR details if found</show_pr_status>
      <show_issue_status>Show related issue status if found</show_issue_status>
      <show_last_activity>Display directory creation/modification date</show_last_activity>
    </summary>
    <safety_checks>
      <check_uncommitted>git status --porcelain in worktree directory</check_uncommitted>
      <warn_if_dirty>Alert user if uncommitted changes exist</warn_if_dirty>
    </safety_checks>
    <ask_deletion>Ask user confirmation: "Delete this worktree? (y/N)"</ask_deletion>
    <purpose>Final safety check before irreversible deletion</purpose>
  </step_8>

  <step_9>
    <description>Delete worktree</description>
    <if_confirmed>
      <remove_worktree>git worktree remove {path} --force</remove_worktree>
      <cleanup_branch>git branch -d {branch_name}</cleanup_branch>
      <success_message>Inform user worktree was successfully removed</success_message>
      <next_steps>Suggest running command again to find next candidate</next_steps>
    </if_confirmed>
    <if_declined>Exit gracefully with no changes</if_declined>
    <purpose>Perform the actual cleanup and guide user for next iteration</purpose>
  </step_9>
</execution_steps>

<important_notes>

- Uses PR/MR merge status as the ONLY reliable way to verify if a branch was merged
- DOES NOT use "git branch --merged" command as it's unreliable for merge verification
- Only processes branches with PRs/MRs that were definitively merged to default branch
- Skips worktrees without merged PRs/MRs and continues to next oldest candidate
- Checks and optionally closes related issues
- Prioritizes oldest worktrees by directory age first for systematic cleanup
- Warns about very recent worktrees (created within 24 hours) to avoid cleaning active work
- Preserves useful development settings before deletion
- Requires explicit confirmation before any destructive actions
- Handles locked worktrees automatically
- Processes one worktree at a time to maintain control
- Must be run from default branch for safety

Limitations:

- Assumes remote is named "origin" (most common convention)
- Supports macOS and Linux only (no Windows support)
- Requires MCP server or CLI for git hosting provider (GitHub, GitLab, etc.)
</important_notes>
"
`;

exports[`downloads/without-beads > should match snapshot for add-command.md 1`] = `
"---
description: Guide for creating new slash commands
argument-hint: <command-name> <description>
---

## General Guidelines

### Output Style

- **Never explicitly mention TDD** in code, comments, commits, PRs, or issues
- Write natural, descriptive code without meta-commentary about the development process
- The code should speak for itself - TDD is the process, not the product

# Slash Command Creator Guide

## How This Command Works

The \`/add-command\` command shows this guide for creating new slash commands. It includes:

- Command structure and syntax
- Common patterns and examples
- Security restrictions and limitations
- Frontmatter options

**Note for AI**: When creating commands, you CAN use bash tools like \`Bash(mkdir:*)\`, \`Bash(ls:*)\`, \`Bash(git status:*)\` in the \`allowed-tools\` frontmatter of NEW commands - but ONLY for operations within the current project directory. This command itself doesn't need bash tools since it's just documentation.

## Command Locations

- **Personal**: \`~/.claude/commands/\` (available across all projects)
- **Project**: \`.claude/commands/\` (shared with team, shows "(project)")

## Basic Structure

\`\`\`markdown
---
allowed-tools: Read, Glob, Grep, Bash(git status:*), Task
description: Brief description of what this command does
argument-hint: [required-arg] [optional-arg]
---

# Command Title

Your command instructions here.

Arguments: $ARGUMENTS

File reference: @path/to/file.js

Bash command output: (exclamation)git status(backticks)
\`\`\`

## ‚ö†Ô∏è Security Restrictions

**Bash Commands (exclamation prefix)**: Limited to current working directory only.

- ‚úÖ Works: \`! + backtick + git status + backtick\` (in project dir)
- ‚ùå Blocked: \`! + backtick + ls /outside/project + backtick\` (outside project)  
- ‚ùå Blocked: \`! + backtick + pwd + backtick\` (if referencing dirs outside project)

**File References (\`@\` prefix)**: No directory restrictions.

- ‚úÖ Works: \`@/path/to/system/file.md\`
- ‚úÖ Works: \`@../other-project/file.js\`

## Common Patterns

### Simple Command

\`\`\`bash
echo "Review this code for bugs and suggest fixes" > ~/.claude/commands/review.md
\`\`\`

### Command with Arguments

**Note for AI**: The example below uses a fullwidth dollar sign (ÔºÑ, U+FF04) to prevent interpolation in this documentation. When creating actual commands, use the regular \`$\` character.

\`\`\`markdown
Fix issue ÔºÑARGUMENTS following our coding standards
\`\`\`

### Command with File References

\`\`\`markdown
Compare @src/old.js with @src/new.js and explain differences
\`\`\`

### Command with Bash Output (Project Directory Only)

\`\`\`markdown
---
allowed-tools: Bash(git status:*), Bash(git branch:*), Bash(git log:*)
---
Current status: (!)git status(\`)
Current branch: (!)git branch --show-current(\`)
Recent commits: (!)git log --oneline -5(\`)

Create commit for these changes.
\`\`\`

**Note**: Only works with commands in the current project directory.

### Namespaced Command

**Note for AI**: The example below uses a fullwidth dollar sign (ÔºÑ, U+FF04) to prevent interpolation in this documentation. When creating actual commands, use the regular \`$\` character.

\`\`\`bash
mkdir -p ~/.claude/commands/ai
echo "Ask GPT-5 about: ÔºÑARGUMENTS" > ~/.claude/commands/ai/gpt5.md
# Creates: /ai:gpt5
\`\`\`

## Frontmatter Options

- \`allowed-tools\`: Tools this command can use
  - **Important**: Intrusive tools like \`Write\`, \`Edit\`, \`NotebookEdit\` should NEVER be allowed in commands unless the user explicitly requests them. These tools modify files and should only be used when the command's purpose is to make changes.
  - ‚úÖ Safe for most commands: \`Read\`, \`Glob\`, \`Grep\`, \`Bash(git status:*)\`, \`Task\`, \`AskUserQuestion\`
- \`description\`: Brief description (shows in /help)
- \`argument-hint\`: Help text for arguments
- \`model\`: Specific model to use

## Best Practices

### Safe Commands (No Security Issues)

\`\`\`markdown
# System prompt editor (file reference only)  
(@)path/to/system/prompt.md

Edit your system prompt above.
\`\`\`

### Project-Specific Commands (Bash OK)

\`\`\`markdown
---
allowed-tools: Bash(git status:*), Bash(npm list:*)
---
Current git status: (!)git status(\`)
Package info: (!)npm list --depth=0(\`)

Review project state and suggest next steps.
\`\`\`

### Cross-Directory File Access (Use @ not !)

\`\`\`markdown
# Compare config files
Compare (@)path/to/system.md with (@)project/config.md

Show differences and suggest improvements.
\`\`\`

## Usage

After creating: \`/<command-name> [arguments]\`

Example: \`/review\` or \`/ai:gpt5 "explain this code"\`
"
`;

exports[`downloads/without-beads > should match snapshot for ask.md 1`] = `
"---
description: Request team review and approval - for complex changes needing discussion
argument-hint: [optional-pr-title-and-description]
---

# Ask - Request Review and Approval

## General Guidelines

### Output Style

- **Never explicitly mention TDD** in code, comments, commits, PRs, or issues
- Write natural, descriptive code without meta-commentary about the development process
- The code should speak for itself - TDD is the process, not the product

**Ship/Show/Ask Pattern - ASK**

Ask is for complex changes that need team discussion and approval. Examples:

- Breaking API changes
- New architecture decisions
- Significant feature additions
- Performance trade-offs
- Security-sensitive changes

## When to Ask

Use **Ask** when:

- Changes affect multiple systems
- Breaking changes are needed
- You need input on approach
- Security implications exist
- Performance trade-offs need discussion
- Uncertain about the best solution

## Workflow

Current branch status:
!\`git status\`

Recent commits:
!\`git log --oneline -5\`

Arguments: $ARGUMENTS

**This is the traditional Pull Request workflow**, but with explicit intent that review and approval are required.

**Process:**

1. **Ensure Branch is Ready**:
   !\`git status\`
   - Commit all changes
   - Push to remote: \`git push origin [branch-name]\`

2. **Create Ask PR**: Create a PR that clearly needs review

   Title: conventional commits format, prefixed with \`[ASK]\`

   Description template:

   \`\`\`markdown
   ## ü§î Ask - Review and Approval Needed

   **This is an ASK PR**: These changes need team review and discussion.

   <!--
     References: [link to relevant issues]
   -->

   ### What changed

   [Detailed description of changes]

   ### Why

   [Rationale and context]

   ### Questions for reviewers

   - [ ] Question 1
   - [ ] Question 2

   ### Concerns

   - Potential concern 1
   - Potential concern 2

   ### Test Plan

   - [ ] Unit tests
   - [ ] Integration tests
   - [ ] Manual testing steps

   ### Alternatives considered

   - Alternative 1: [why not chosen]
   - Alternative 2: [why not chosen]
   \`\`\`

3. **Request Reviewers**: Assign specific reviewers who should weigh in

4. **Add Labels**:
   - "needs-review"
   - "breaking-change" (if applicable)
   - "security" (if applicable)

5. **Link Issues**: Reference related issues in the description

6. **Monitor Discussion**: Be responsive to reviewer feedback and questions

## Use GitHub MCP Tools

1. Check current branch and ensure it's pushed
2. Create a well-formatted pull request with [ASK] prefix
3. Set reviewers
4. Add appropriate labels
5. Link related issues from commit messages

## Decision Guide

Use **Ask** when:

- ‚úÖ Change is complex or risky
- ‚úÖ Breaking changes involved
- ‚úÖ Need team input on approach
- ‚úÖ Multiple solutions possible
- ‚úÖ Security implications

Use **/show** instead if: confident in approach, just want visibility

Use **/ship** instead if: change is tiny, obvious, and safe
"
`;

exports[`downloads/without-beads > should match snapshot for beepboop.md 1`] = `
"---
description: Communicate AI-generated content with transparent attribution
argument-hint: <task-description>
---

# AI-Attributed Communication Command

Execute the user's requested task (e.g., posting PR comments, GitHub issue comments, or other communications through various MCPs), but frame the output with clear AI attribution.

## General Guidelines

### Output Style

- **Never explicitly mention TDD** in code, comments, commits, PRs, or issues
- Write natural, descriptive code without meta-commentary about the development process
- The code should speak for itself - TDD is the process, not the product

## Instructions

Arguments: $ARGUMENTS

**IMPORTANT Communication Format:**

1. **Opening**: Begin with "*Beep boop, I am Claude Code ü§ñ, my user has reviewed and approved the following written by me:*"
   - Use italics for this line
   - Clearly establishes AI authorship

2. **Middle**: Perform the requested task (post comment, create review, etc.)
   - Execute whatever communication task the user requested
   - Write the actual content that accomplishes the user's goal

3. **Closing**: End with "*Beep boop, Claude Code ü§ñ out!*"
   - Use italics for this line
   - Provides clear closure

## Purpose

This command ensures transparency about AI usage while maintaining that the user has reviewed and approved the content. It prevents offloading review responsibility to other users while being open about AI assistance.

## Examples

- Posting a GitHub PR review comment
- Adding a comment to a GitHub issue
- Responding to feedback with AI-generated explanations
- Any communication where AI attribution is valuable
"
`;

exports[`downloads/without-beads > should match snapshot for busycommit.md 1`] = `
"---
description: Create multiple atomic git commits, one logical change at a time
argument-hint: [optional-commit-description]
---

## General Guidelines

### Output Style

- **Never explicitly mention TDD** in code, comments, commits, PRs, or issues
- Write natural, descriptive code without meta-commentary about the development process
- The code should speak for itself - TDD is the process, not the product

Create multiple atomic git commits, committing the smallest possible logical unit at a time

Include any of the following info if specified: $ARGUMENTS

## Commit Message Rules

Follows [Conventional Commits](https://www.conventionalcommits.org/) standard.

1. **Format**: \`type(#issue): description\`
   - Use \`#123\` for local repo issues
   - Use \`owner/repo#123\` for cross-repo issues
   - Common types: \`feat\`, \`fix\`, \`docs\`, \`refactor\`, \`test\`, \`chore\`

2. **AI Credits**: **NEVER include AI credits in commit messages**
   - No "Generated with Claude Code"
   - No "Co-Authored-By: Claude" or "Co-Authored-By: Happy"
   - Focus on the actual changes made, not conversation history

3. **Content**: Write clear, concise commit messages describing what changed and why

## Process

1. Run \`git status\` and \`git diff\` to review changes
2. Run \`git log --oneline -5\` to see recent commit style
3. Stage relevant files with \`git add\`
4. Create commit with descriptive message
5. Verify with \`git status\`

## Example

\`\`\`bash
git add <files>
git commit -m "feat(#123): add validation to user input form"
\`\`\`

## Atomic Commit Approach

Each commit should represent ONE logical change. Do NOT bundle multiple unrelated changes into one commit.

- Identify the smallest atomic units of change
- For EACH atomic unit: stage only those files/hunks, commit, verify
- Use \`git add -p\` to stage partial file changes when a file contains multiple logical changes
- Repeat until all changes are committed
- It is OK to create multiple commits without stopping - keep going until \`git status\` shows clean

## Multi-Commit Example

If a single file contains multiple unrelated changes, use \`git add -p\` to stage hunks interactively:

\`\`\`bash
# Stage only the validation-related hunks from the file
git add -p src/user-service.ts
# Select 'y' for validation hunks, 'n' for others
git commit -m "feat(#123): add email format validation"

# Stage the error handling hunks
git add -p src/user-service.ts
git commit -m "fix(#124): handle null user gracefully"

# Stage remaining changes
git add src/user-service.ts
git commit -m "refactor: extract user lookup to helper"
\`\`\`
"
`;

exports[`downloads/without-beads > should match snapshot for code-review.md 1`] = `
"---
description: Code review using dynamic category detection and domain-specific analysis
argument-hint: (optional) [branch, PR#, or PR URL] - defaults to current branch
  - Bash(git diff:*)
  - Bash(git status:*)
  - Bash(git log:*)
  - Bash(git rev-parse:*)
  - Bash(git merge-base:*)
  - Bash(git branch:*)
---

## General Guidelines

### Output Style

- **Never explicitly mention TDD** in code, comments, commits, PRs, or issues
- Write natural, descriptive code without meta-commentary about the development process
- The code should speak for itself - TDD is the process, not the product

# Code Review

Perform a code review using dynamic category detection.

## Phase 0: Setup & Categorization

### Determine What to Review

Parse the argument to determine the review target:

| Input | Action |
|-------|--------|
| No argument | Detect divergence point, confirm scope with user |
| Branch name | Use specified branch as base |
| PR number (e.g., \`123\`) | Fetch PR diff from GitHub |
| PR URL (e.g., \`https://github.com/owner/repo/pull/123\`) | Extract PR number and fetch diff |

**For GitHub PRs:**

1. Try GitHub MCP first: \`mcp__github__pull_request_read\` with \`method: "get_diff"\`
2. Fall back to \`gh\` CLI: \`gh pr diff <number>\`
3. If neither works, report error and stop

**For local branches (no argument or branch name provided):**

1. **Get current branch**: \`git rev-parse --abbrev-ref HEAD\`

2. **Check for uncommitted changes**: \`git status --porcelain\`
   - If output is non-empty, note that uncommitted changes exist

3. **Detect divergence point** (skip if branch name was provided as argument):
   - Get all local branches except current: \`git branch --format='%(refname:short)'\`
   - For each branch, find merge-base: \`git merge-base HEAD <branch>\`
   - Count commits from merge-base to HEAD: \`git rev-list --count <merge-base>..HEAD\`
   - The branch with the **fewest commits back** (closest merge-base) is the likely parent
   - If no other branches exist, fall back to \`main\`, \`master\`, or \`develop\` if they exist as remote tracking branches

4. **Confirm scope with user** using \`AskUserQuestion\`:

   **Question 1 - "Review scope"** (header: "Base branch"):
   - Option A: \`From <detected-branch>\` ‚Äî "Review N commits since diverging from <branch>"
   - Option B: \`Different branch\` ‚Äî "Specify another branch to compare against"
   - Option C: \`Uncommitted only\` ‚Äî "Review only staged/unstaged changes, skip committed work"

   **Question 2 - "Include uncommitted?"** (header: "Uncommitted", only ask if uncommitted changes exist AND user didn't pick option C):
   - Option A: \`Yes\` ‚Äî "Include N staged/unstaged files in review"
   - Option B: \`No\` ‚Äî "Review only committed changes"

5. **Collect changed files** based on user selection:
   - From branch: \`git diff --name-only <base>...HEAD\`
   - Uncommitted unstaged: \`git diff --name-only\`
   - Uncommitted staged: \`git diff --name-only --cached\`
   - Combine and deduplicate the file list

6. **If no changes**: Report "Nothing to review" and stop

### Categorize Files

Check for CLAUDE.md - if it exists, note any project-specific review patterns.

Categorize each changed file into ONE primary category based on these patterns:

| Category | File Patterns |
|----------|---------------|
| Frontend/UI | \`*.tsx\`, \`*.jsx\`, \`components/\`, \`pages/\`, \`views/\`, \`*.vue\` |
| Frontend/Styling | \`*.css\`, \`*.scss\`, \`*.less\`, \`styles/\`, \`*.tailwind*\`, \`*.styled.*\` |
| Backend/API | \`routes/\`, \`api/\`, \`controllers/\`, \`services/\`, \`*.controller.*\`, \`*.service.*\`, \`*.resolver.*\` |
| Backend/Data | \`migrations/\`, \`models/\`, \`prisma/\`, \`schema.*\`, \`*.model.*\`, \`*.entity.*\` |
| Tooling/Config | \`scripts/\`, \`*.config.*\`, \`package.json\`, \`tsconfig.*\`, \`vite.*\`, \`webpack.*\`, \`eslint.*\` |
| CI/CD | \`.github/\`, \`.gitlab-ci.*\`, \`Dockerfile\`, \`docker-compose.*\`, \`*.yml\` in CI paths |
| Tests | \`*.test.*\`, \`*.spec.*\`, \`__tests__/\`, \`__mocks__/\`, \`*.stories.*\` |
| Docs | \`*.md\`, \`docs/\`, \`README*\`, \`CHANGELOG*\` |

Output the categorization:

\`\`\`
## Categorization

Base branch: <branch>
Total files changed: <n>

| Category | Files |
|----------|-------|
| <category> | <count> |
...
\`\`\`

## Phase 1: Branch Brief

From the diff and recent commit messages (\`git log <base>...HEAD --oneline\`), infer:

- **Goal**: What this branch accomplishes (1-3 sentences)
- **Constraints**: Any implied requirements (security, performance, backwards compatibility)
- **Success checklist**: What must work after this change, what must not break

\`\`\`
## Branch Brief

**Goal**: ...
**Constraints**: ...
**Checklist**:
- [ ] ...
\`\`\`

## Phase 2: Category Reviews

For each detected category with changes, run a targeted review. Skip categories with no changes.

### Frontend/UI Review Criteria

- Accessibility: ARIA attributes, keyboard navigation, screen reader support
- Component patterns: Composition, prop drilling, context usage
- State management: Unnecessary re-renders, stale closures
- Performance: memo/useMemo/useCallback usage, lazy loading, bundle impact

### Frontend/Styling Review Criteria

- Responsive design: Breakpoints, mobile-first
- Design system: Token usage, consistent spacing/colors
- CSS specificity: Overly specific selectors, !important usage
- Theme support: Dark mode, CSS variables

### Backend/API Review Criteria

- Input validation: Sanitization, type checking, bounds
- Security: Authentication checks, authorization, injection risks
- Error handling: Proper status codes, meaningful messages, logging
- Performance: N+1 queries, missing indexes, pagination

### Backend/Data Review Criteria

- Migration safety: Reversibility, data preservation
- Data integrity: Constraints, foreign keys, nullability
- Index usage: Queries have appropriate indexes
- Backwards compatibility: Existing data still works

### Tooling/Config Review Criteria

- Breaking changes: Does this affect developer workflow?
- Dependency compatibility: Version conflicts, peer deps
- Build performance: Added build time, bundle size

### CI/CD Review Criteria

- Secrets exposure: Credentials in logs, env vars
- Pipeline efficiency: Caching, parallelization
- Failure handling: Notifications, rollback strategy

### Tests Review Criteria

- Coverage: Edge cases, error paths, boundaries
- Assertion quality: Specific assertions, not just "no error"
- Flaky patterns: Timing dependencies, order dependencies, shared state

### Docs Review Criteria

- Technical accuracy: Code examples work, APIs documented correctly
- Completeness: All new features documented
- Clarity: Easy to follow, good examples

**Output format per category:**

\`\`\`
## <Category> Review (<n> files)

### file:line - [blocker|risky|nit] Title
Description of the issue and why it matters.
Suggested fix or question to investigate.

...
\`\`\`

## Phase 3: Cross-Cutting Analysis

After reviewing all categories, check for cross-cutting issues:

- API changed but tests didn't update?
- New feature but no documentation?
- Migration added but no rollback tested?
- Config changed but README not updated?
- Security-sensitive code without corresponding test?

\`\`\`
## Cross-Cutting Issues

- [ ] <issue description>
...
\`\`\`

## Phase 4: Summary

### PR Description (draft)

Provide a ready-to-paste PR description:

\`\`\`
## What changed
- <by category, 1-2 bullets each>

## Why
- <motivation>

## Testing
- <how to verify>

## Notes
- <migration steps, breaking changes, etc.>
\`\`\`

### Review Checklist

\`\`\`
## Before Merge

### Blockers (must fix)
- [ ] ...

### Risky (highlight to reviewers)
- [ ] ...

### Follow-ups (can defer)
- [ ] ...
\`\`\`

---

Review target (branch name, PR number, or PR URL - leave empty for current branch): $ARGUMENTS
"
`;

exports[`downloads/without-beads > should match snapshot for commit.md 1`] = `
"---
description: Create a git commit following project standards
argument-hint: [optional-commit-description]
---

## General Guidelines

### Output Style

- **Never explicitly mention TDD** in code, comments, commits, PRs, or issues
- Write natural, descriptive code without meta-commentary about the development process
- The code should speak for itself - TDD is the process, not the product

Create a git commit following project standards

Include any of the following info if specified: $ARGUMENTS

## Commit Message Rules

Follows [Conventional Commits](https://www.conventionalcommits.org/) standard.

1. **Format**: \`type(#issue): description\`
   - Use \`#123\` for local repo issues
   - Use \`owner/repo#123\` for cross-repo issues
   - Common types: \`feat\`, \`fix\`, \`docs\`, \`refactor\`, \`test\`, \`chore\`

2. **AI Credits**: **NEVER include AI credits in commit messages**
   - No "Generated with Claude Code"
   - No "Co-Authored-By: Claude" or "Co-Authored-By: Happy"
   - Focus on the actual changes made, not conversation history

3. **Content**: Write clear, concise commit messages describing what changed and why

## Process

1. Run \`git status\` and \`git diff\` to review changes
2. Run \`git log --oneline -5\` to see recent commit style
3. Stage relevant files with \`git add\`
4. Create commit with descriptive message
5. Verify with \`git status\`

## Example

\`\`\`bash
git add <files>
git commit -m "feat(#123): add validation to user input form"
\`\`\`
"
`;

exports[`downloads/without-beads > should match snapshot for cycle.md 1`] = `
"---
description: Execute complete TDD cycle - Red, Green, and Refactor phases in sequence
argument-hint: <feature or requirement description>
---

RED+GREEN+REFACTOR (one cycle) PHASE! Apply the below to the info given by user input here:

$ARGUMENTS

## General Guidelines

### Output Style

- **Never explicitly mention TDD** in code, comments, commits, PRs, or issues
- Write natural, descriptive code without meta-commentary about the development process
- The code should speak for itself - TDD is the process, not the product

(If there was no info above, fallback to the context of the conversation)

## TDD Fundamentals

### The TDD Cycle

The foundation of TDD is the Red-Green-Refactor cycle:

1. **Red Phase**: Write ONE failing test that describes desired behavior

   - The test must fail for the RIGHT reason (not syntax/import errors)
   - Only one test at a time - this is critical for TDD discipline
     - Exception: For browser-level tests or expensive setup (e.g., Storybook \`*.stories.tsx\`), group multiple assertions within a single test block to avoid redundant setup - but only when adding assertions to an existing interaction flow. If new user interactions are required, still create a new test. Split files by category if they exceed ~1000 lines.
   - **Adding a single test to a test file is ALWAYS allowed** - no prior test output needed
   - Starting TDD for a new feature is always valid, even if test output shows unrelated work
   - For DOM-based tests, use \`data-testid\` attributes to select elements rather than CSS classes, tag names, or text content
   - Avoid hard-coded timeouts both in form of sleep() or timeout: 5000 etc; use proper async patterns (\`waitFor\`, \`findBy*\`, event-based sync) instead and rely on global test configs for timeout settings

2. **Green Phase**: Write MINIMAL code to make the test pass

   - Implement only what's needed for the current failing test
   - No anticipatory coding or extra features
   - Address the specific failure message

3. **Refactor Phase**: Improve code structure while keeping tests green
   - Only allowed when relevant tests are passing
   - Requires proof that tests have been run and are green
   - Applies to BOTH implementation and test code
   - No refactoring with failing tests - fix them first

### Core Violations

1. **Multiple Test Addition**

   - Adding more than one new test at once
   - Exception: Initial test file setup or extracting shared test utilities

2. **Over-Implementation**

   - Code that exceeds what's needed to pass the current failing test
   - Adding untested features, methods, or error handling
   - Implementing multiple methods when test only requires one

3. **Premature Implementation**
   - Adding implementation before a test exists and fails properly
   - Adding implementation without running the test first
   - Refactoring when tests haven't been run or are failing

### Critical Principle: Incremental Development

Each step in TDD should address ONE specific issue:

- Test fails "not defined" ‚Üí Create empty stub/class only
- Test fails "not a function" ‚Üí Add method stub only
- Test fails with assertion ‚Üí Implement minimal logic only

### Optional Pre-Phase: Spike Phase

In rare cases where the problem space, interface, or expected behavior is unclear, a **Spike Phase** may be used **before the Red Phase**.
This phase is **not part of the regular TDD workflow** and must only be applied under exceptional circumstances.

- The goal of a Spike is **exploration and learning**, not implementation.
- The code written during a Spike is **disposable** and **must not** be merged or reused directly.
- Once sufficient understanding is achieved, all spike code is discarded, and normal TDD resumes starting from the **Red Phase**.
- A Spike is justified only when it is impossible to define a meaningful failing test due to technical uncertainty or unknown system behavior.

### General Information

- Sometimes the test output shows as no tests have been run when a new test is failing due to a missing import or constructor. In such cases, allow the agent to create simple stubs. Ask them if they forgot to create a stub if they are stuck.
- It is never allowed to introduce new logic without evidence of relevant failing tests. However, stubs and simple implementation to make imports and test infrastructure work is fine.
- In the refactor phase, it is perfectly fine to refactor both test and implementation code. That said, completely new functionality is not allowed. Types, clean up, abstractions, and helpers are allowed as long as they do not introduce new behavior.
- Adding types, interfaces, or a constant in order to replace magic values is perfectly fine during refactoring.
- Provide the agent with helpful directions so that they do not get stuck when blocking them.
"
`;

exports[`downloads/without-beads > should match snapshot for gap.md 1`] = `
"---
description: Analyze conversation context for unaddressed items and gaps
argument-hint: [optional additional info]
---

## General Guidelines

### Output Style

- **Never explicitly mention TDD** in code, comments, commits, PRs, or issues
- Write natural, descriptive code without meta-commentary about the development process
- The code should speak for itself - TDD is the process, not the product

Analyze the current conversation context and identify things that have not yet been addressed. Look for:

1. **Incomplete implementations** - Code that was started but not finished
2. **Unused variables/results** - Values that were captured but never used
3. **Missing tests** - Functionality without test coverage

4. **User requests** - Things the user asked for that weren't fully completed
5. **TODO comments** - Any TODOs mentioned in conversation
6. **Error handling gaps** - Missing error cases or edge cases
7. **Documentation gaps** - Undocumented APIs or features
8. **Consistency check** - Look for inconsistent patterns, naming conventions, or structure across the codebase

Present findings as a prioritized list with:

- What the gap is
- Why it matters
- Suggested next action

If there are no gaps, confirm that everything discussed has been addressed.

Additional info:
$ARGUMENTS
"
`;

exports[`downloads/without-beads > should match snapshot for green.md 1`] = `
"---
description: Execute TDD Green Phase - write minimal implementation to pass the failing test
argument-hint: <implementation description>
---

GREEN PHASE! Apply the below to the info given by user input here:

$ARGUMENTS

## General Guidelines

### Output Style

- **Never explicitly mention TDD** in code, comments, commits, PRs, or issues
- Write natural, descriptive code without meta-commentary about the development process
- The code should speak for itself - TDD is the process, not the product

(If there was no info above, fallback to the context of the conversation)

## TDD Fundamentals

### The TDD Cycle

The foundation of TDD is the Red-Green-Refactor cycle:

1. **Red Phase**: Write ONE failing test that describes desired behavior

   - The test must fail for the RIGHT reason (not syntax/import errors)
   - Only one test at a time - this is critical for TDD discipline
     - Exception: For browser-level tests or expensive setup (e.g., Storybook \`*.stories.tsx\`), group multiple assertions within a single test block to avoid redundant setup - but only when adding assertions to an existing interaction flow. If new user interactions are required, still create a new test. Split files by category if they exceed ~1000 lines.
   - **Adding a single test to a test file is ALWAYS allowed** - no prior test output needed
   - Starting TDD for a new feature is always valid, even if test output shows unrelated work
   - For DOM-based tests, use \`data-testid\` attributes to select elements rather than CSS classes, tag names, or text content
   - Avoid hard-coded timeouts both in form of sleep() or timeout: 5000 etc; use proper async patterns (\`waitFor\`, \`findBy*\`, event-based sync) instead and rely on global test configs for timeout settings

2. **Green Phase**: Write MINIMAL code to make the test pass

   - Implement only what's needed for the current failing test
   - No anticipatory coding or extra features
   - Address the specific failure message

3. **Refactor Phase**: Improve code structure while keeping tests green
   - Only allowed when relevant tests are passing
   - Requires proof that tests have been run and are green
   - Applies to BOTH implementation and test code
   - No refactoring with failing tests - fix them first

### Core Violations

1. **Multiple Test Addition**

   - Adding more than one new test at once
   - Exception: Initial test file setup or extracting shared test utilities

2. **Over-Implementation**

   - Code that exceeds what's needed to pass the current failing test
   - Adding untested features, methods, or error handling
   - Implementing multiple methods when test only requires one

3. **Premature Implementation**
   - Adding implementation before a test exists and fails properly
   - Adding implementation without running the test first
   - Refactoring when tests haven't been run or are failing

### Critical Principle: Incremental Development

Each step in TDD should address ONE specific issue:

- Test fails "not defined" ‚Üí Create empty stub/class only
- Test fails "not a function" ‚Üí Add method stub only
- Test fails with assertion ‚Üí Implement minimal logic only

### Optional Pre-Phase: Spike Phase

In rare cases where the problem space, interface, or expected behavior is unclear, a **Spike Phase** may be used **before the Red Phase**.
This phase is **not part of the regular TDD workflow** and must only be applied under exceptional circumstances.

- The goal of a Spike is **exploration and learning**, not implementation.
- The code written during a Spike is **disposable** and **must not** be merged or reused directly.
- Once sufficient understanding is achieved, all spike code is discarded, and normal TDD resumes starting from the **Red Phase**.
- A Spike is justified only when it is impossible to define a meaningful failing test due to technical uncertainty or unknown system behavior.

### General Information

- Sometimes the test output shows as no tests have been run when a new test is failing due to a missing import or constructor. In such cases, allow the agent to create simple stubs. Ask them if they forgot to create a stub if they are stuck.
- It is never allowed to introduce new logic without evidence of relevant failing tests. However, stubs and simple implementation to make imports and test infrastructure work is fine.
- In the refactor phase, it is perfectly fine to refactor both test and implementation code. That said, completely new functionality is not allowed. Types, clean up, abstractions, and helpers are allowed as long as they do not introduce new behavior.
- Adding types, interfaces, or a constant in order to replace magic values is perfectly fine during refactoring.
- Provide the agent with helpful directions so that they do not get stuck when blocking them.
"
`;

exports[`downloads/without-beads > should match snapshot for issue.md 1`] = `
"---
description: Analyze GitHub issue and create TDD implementation plan
argument-hint: [optional-issue-number]
---

Analyze GitHub issue and create TDD implementation plan.

## General Guidelines

### Output Style

- **Never explicitly mention TDD** in code, comments, commits, PRs, or issues
- Write natural, descriptive code without meta-commentary about the development process
- The code should speak for itself - TDD is the process, not the product

Process:

1. Get Issue Number

- Either from branch name use that issue number
  - Patterns: issue-123, 123-feature, feature/123, fix/123
- Or from this bullet point with custom info: $ARGUMENTS
- If not found: ask user

1. Fetch Issue

Try to fetch the issue using GitHub MCP (mcp__github__issue_read tool).

If GitHub MCP is not configured, show:

\`\`\`
GitHub MCP not configured!
See: https://github.com/modelcontextprotocol/servers/tree/main/src/github
Trying GitHub CLI fallback...
\`\`\`

Then try using \`gh issue view [ISSUE_NUMBER] --json\` as fallback.

1. Analyze and Plan

Summarize the issue and requirements, then:

## Discovery Phase

Understand the requirement by asking (use AskUserQuestion if needed):

**Problem Statement**

- What problem does this solve?
- Who experiences this problem?
- What's the current pain point?

**Desired Outcome**

- What should happen after this is built?
- How will users interact with it?
- What does success look like?

**Scope & Constraints**

- What's in scope vs. out of scope?
- Any technical constraints?
- Dependencies on other systems/features?

**Context Check**

- Search codebase for related features/modules
- Check for existing test files that might be relevant

## TDD Fundamentals

### The TDD Cycle

The foundation of TDD is the Red-Green-Refactor cycle:

1. **Red Phase**: Write ONE failing test that describes desired behavior

   - The test must fail for the RIGHT reason (not syntax/import errors)
   - Only one test at a time - this is critical for TDD discipline
     - Exception: For browser-level tests or expensive setup (e.g., Storybook \`*.stories.tsx\`), group multiple assertions within a single test block to avoid redundant setup - but only when adding assertions to an existing interaction flow. If new user interactions are required, still create a new test. Split files by category if they exceed ~1000 lines.
   - **Adding a single test to a test file is ALWAYS allowed** - no prior test output needed
   - Starting TDD for a new feature is always valid, even if test output shows unrelated work
   - For DOM-based tests, use \`data-testid\` attributes to select elements rather than CSS classes, tag names, or text content
   - Avoid hard-coded timeouts both in form of sleep() or timeout: 5000 etc; use proper async patterns (\`waitFor\`, \`findBy*\`, event-based sync) instead and rely on global test configs for timeout settings

2. **Green Phase**: Write MINIMAL code to make the test pass

   - Implement only what's needed for the current failing test
   - No anticipatory coding or extra features
   - Address the specific failure message

3. **Refactor Phase**: Improve code structure while keeping tests green
   - Only allowed when relevant tests are passing
   - Requires proof that tests have been run and are green
   - Applies to BOTH implementation and test code
   - No refactoring with failing tests - fix them first

### Core Violations

1. **Multiple Test Addition**

   - Adding more than one new test at once
   - Exception: Initial test file setup or extracting shared test utilities

2. **Over-Implementation**

   - Code that exceeds what's needed to pass the current failing test
   - Adding untested features, methods, or error handling
   - Implementing multiple methods when test only requires one

3. **Premature Implementation**
   - Adding implementation before a test exists and fails properly
   - Adding implementation without running the test first
   - Refactoring when tests haven't been run or are failing

### Critical Principle: Incremental Development

Each step in TDD should address ONE specific issue:

- Test fails "not defined" ‚Üí Create empty stub/class only
- Test fails "not a function" ‚Üí Add method stub only
- Test fails with assertion ‚Üí Implement minimal logic only

### Optional Pre-Phase: Spike Phase

In rare cases where the problem space, interface, or expected behavior is unclear, a **Spike Phase** may be used **before the Red Phase**.
This phase is **not part of the regular TDD workflow** and must only be applied under exceptional circumstances.

- The goal of a Spike is **exploration and learning**, not implementation.
- The code written during a Spike is **disposable** and **must not** be merged or reused directly.
- Once sufficient understanding is achieved, all spike code is discarded, and normal TDD resumes starting from the **Red Phase**.
- A Spike is justified only when it is impossible to define a meaningful failing test due to technical uncertainty or unknown system behavior.

### General Information

- Sometimes the test output shows as no tests have been run when a new test is failing due to a missing import or constructor. In such cases, allow the agent to create simple stubs. Ask them if they forgot to create a stub if they are stuck.
- It is never allowed to introduce new logic without evidence of relevant failing tests. However, stubs and simple implementation to make imports and test infrastructure work is fine.
- In the refactor phase, it is perfectly fine to refactor both test and implementation code. That said, completely new functionality is not allowed. Types, clean up, abstractions, and helpers are allowed as long as they do not introduce new behavior.
- Adding types, interfaces, or a constant in order to replace magic values is perfectly fine during refactoring.
- Provide the agent with helpful directions so that they do not get stuck when blocking them.
"
`;

exports[`downloads/without-beads > should match snapshot for plan.md 1`] = `
"---
description: Create implementation plan from feature/requirement with PRD-style discovery and TDD acceptance criteria
argument-hint: <feature/requirement description or GitHub issue URL/number>
---

# Plan: PRD-Informed Task Planning for TDD

Create structured implementation plan that bridges product thinking (PRD) with test-driven development.

## General Guidelines

### Output Style

- **Never explicitly mention TDD** in code, comments, commits, PRs, or issues
- Write natural, descriptive code without meta-commentary about the development process
- The code should speak for itself - TDD is the process, not the product

## Input

$ARGUMENTS

(If no input provided, check conversation context)

## Input Processing

The input can be one of:

1. **GitHub Issue URL** (e.g., \`https://github.com/owner/repo/issues/123\`)
2. **GitHub Issue Number** (e.g., \`#123\` or \`123\`)
3. **Feature Description** (e.g., "Add user authentication")
4. **Empty** - use conversation context

### GitHub Issue Integration

If input looks like a GitHub issue:

**Step 1: Extract Issue Number**

- From URL: extract owner/repo/number
- From number: try to infer repo from git remote
- From branch name: check patterns like \`issue-123\`, \`123-feature\`, \`feature/123\`

**Step 2: Fetch Issue**
Try GitHub MCP first:

- If available: use \`mcp__github__issue_read\` to fetch issue details
- If not available: show message and try \`gh issue view <number>\`

\`\`\`
GitHub MCP not configured!
See: https://github.com/modelcontextprotocol/servers/tree/main/src/github
Trying GitHub CLI fallback...
\`\`\`

**Step 3: Use Issue as Discovery Input**

- Title ‚Üí Feature name
- Description ‚Üí Problem statement and context
- Labels ‚Üí Type/priority hints
- Comments ‚Üí Additional requirements and discussion
- Linked issues ‚Üí Dependencies

Extract from GitHub issue:

- Problem statement and context
- Acceptance criteria (if present)
- Technical notes (if present)
- Related issues/dependencies

## Process

## Discovery Phase

Understand the requirement by asking (use AskUserQuestion if needed):

**Problem Statement**

- What problem does this solve?
- Who experiences this problem?
- What's the current pain point?

**Desired Outcome**

- What should happen after this is built?
- How will users interact with it?
- What does success look like?

**Scope & Constraints**

- What's in scope vs. out of scope?
- Any technical constraints?
- Dependencies on other systems/features?

**Context Check**

- Search codebase for related features/modules
- Check for existing test files that might be relevant

## Key Principles

**From PRD World:**

- Start with user problems, not solutions
- Define success criteria upfront
- Understand constraints and scope

**From TDD World:**

- Make acceptance criteria test-ready
- Break work into small, testable pieces
- Each task should map to test(s)

## Integration with Other Commands

- **Before /plan**: Use \`/spike\` if you need technical exploration first
- **After /plan**: Use \`/red\` to start TDD on first task
"
`;

exports[`downloads/without-beads > should match snapshot for pr.md 1`] = `
"---
description: Creates a pull request using GitHub MCP
argument-hint: [optional-pr-title-and-description]
---

# Create Pull Request

## General Guidelines

### Output Style

- **Never explicitly mention TDD** in code, comments, commits, PRs, or issues
- Write natural, descriptive code without meta-commentary about the development process
- The code should speak for itself - TDD is the process, not the product

Create a pull request for the current branch using GitHub MCP tools.

## Workflow

Current branch status:
!\`git status\`

Recent commits:
!\`git log --oneline -5\`

Arguments: $ARGUMENTS

**Process:**

1. **Ensure Branch is Ready**:
   !\`git status\`
   - Commit all changes
   - Push to remote: \`git push origin [branch-name]\`

2. **Create PR**: Create a well-formatted pull request

   Title: conventional commits format, like \`feat(#123): add user authentication\`

   Description template:

   \`\`\`markdown
   <!--
     Are there any relevant issues / PRs / mailing lists discussions?
     Please reference them here.
   -->

   ## References

   - [links to github issues referenced in commit messages]

   ## Summary

   [Brief description of changes]

   ## Test Plan

   - [ ] Tests pass
   - [ ] Manual testing completed
   \`\`\`

3. **Set Base Branch**: Default to main unless specified otherwise

4. **Link Issues**: Reference related issues found in commit messages

## Use GitHub MCP Tools

1. Check current branch and ensure it's pushed
2. Create a well-formatted pull request with proper title and description
3. Set the base branch (default: main)
4. Include relevant issue references if found in commit messages
"
`;

exports[`downloads/without-beads > should match snapshot for red.md 1`] = `
"---
description: Execute TDD Red Phase - write ONE failing test
argument-hint: [optional additional info]
---

RED PHASE! Apply the below to the info given by user input here:

$ARGUMENTS

## General Guidelines

### Output Style

- **Never explicitly mention TDD** in code, comments, commits, PRs, or issues
- Write natural, descriptive code without meta-commentary about the development process
- The code should speak for itself - TDD is the process, not the product

(If there was no info above, fallback to the context of the conversation)

## TDD Fundamentals

### The TDD Cycle

The foundation of TDD is the Red-Green-Refactor cycle:

1. **Red Phase**: Write ONE failing test that describes desired behavior

   - The test must fail for the RIGHT reason (not syntax/import errors)
   - Only one test at a time - this is critical for TDD discipline
     - Exception: For browser-level tests or expensive setup (e.g., Storybook \`*.stories.tsx\`), group multiple assertions within a single test block to avoid redundant setup - but only when adding assertions to an existing interaction flow. If new user interactions are required, still create a new test. Split files by category if they exceed ~1000 lines.
   - **Adding a single test to a test file is ALWAYS allowed** - no prior test output needed
   - Starting TDD for a new feature is always valid, even if test output shows unrelated work
   - For DOM-based tests, use \`data-testid\` attributes to select elements rather than CSS classes, tag names, or text content
   - Avoid hard-coded timeouts both in form of sleep() or timeout: 5000 etc; use proper async patterns (\`waitFor\`, \`findBy*\`, event-based sync) instead and rely on global test configs for timeout settings

2. **Green Phase**: Write MINIMAL code to make the test pass

   - Implement only what's needed for the current failing test
   - No anticipatory coding or extra features
   - Address the specific failure message

3. **Refactor Phase**: Improve code structure while keeping tests green
   - Only allowed when relevant tests are passing
   - Requires proof that tests have been run and are green
   - Applies to BOTH implementation and test code
   - No refactoring with failing tests - fix them first

### Core Violations

1. **Multiple Test Addition**

   - Adding more than one new test at once
   - Exception: Initial test file setup or extracting shared test utilities

2. **Over-Implementation**

   - Code that exceeds what's needed to pass the current failing test
   - Adding untested features, methods, or error handling
   - Implementing multiple methods when test only requires one

3. **Premature Implementation**
   - Adding implementation before a test exists and fails properly
   - Adding implementation without running the test first
   - Refactoring when tests haven't been run or are failing

### Critical Principle: Incremental Development

Each step in TDD should address ONE specific issue:

- Test fails "not defined" ‚Üí Create empty stub/class only
- Test fails "not a function" ‚Üí Add method stub only
- Test fails with assertion ‚Üí Implement minimal logic only

### Optional Pre-Phase: Spike Phase

In rare cases where the problem space, interface, or expected behavior is unclear, a **Spike Phase** may be used **before the Red Phase**.
This phase is **not part of the regular TDD workflow** and must only be applied under exceptional circumstances.

- The goal of a Spike is **exploration and learning**, not implementation.
- The code written during a Spike is **disposable** and **must not** be merged or reused directly.
- Once sufficient understanding is achieved, all spike code is discarded, and normal TDD resumes starting from the **Red Phase**.
- A Spike is justified only when it is impossible to define a meaningful failing test due to technical uncertainty or unknown system behavior.

### General Information

- Sometimes the test output shows as no tests have been run when a new test is failing due to a missing import or constructor. In such cases, allow the agent to create simple stubs. Ask them if they forgot to create a stub if they are stuck.
- It is never allowed to introduce new logic without evidence of relevant failing tests. However, stubs and simple implementation to make imports and test infrastructure work is fine.
- In the refactor phase, it is perfectly fine to refactor both test and implementation code. That said, completely new functionality is not allowed. Types, clean up, abstractions, and helpers are allowed as long as they do not introduce new behavior.
- Adding types, interfaces, or a constant in order to replace magic values is perfectly fine during refactoring.
- Provide the agent with helpful directions so that they do not get stuck when blocking them.
"
`;

exports[`downloads/without-beads > should match snapshot for refactor.md 1`] = `
"---
description: Execute TDD Refactor Phase - improve code structure while keeping tests green
argument-hint: <refactoring description>
---

Apply this document (specifically the Refactor phase), to the info given by user input here: $ARGUMENTS

## General Guidelines

### Output Style

- **Never explicitly mention TDD** in code, comments, commits, PRs, or issues
- Write natural, descriptive code without meta-commentary about the development process
- The code should speak for itself - TDD is the process, not the product

(If there was no info above, fallback to the context of the conversation)

## TDD Fundamentals

### The TDD Cycle

The foundation of TDD is the Red-Green-Refactor cycle:

1. **Red Phase**: Write ONE failing test that describes desired behavior

   - The test must fail for the RIGHT reason (not syntax/import errors)
   - Only one test at a time - this is critical for TDD discipline
     - Exception: For browser-level tests or expensive setup (e.g., Storybook \`*.stories.tsx\`), group multiple assertions within a single test block to avoid redundant setup - but only when adding assertions to an existing interaction flow. If new user interactions are required, still create a new test. Split files by category if they exceed ~1000 lines.
   - **Adding a single test to a test file is ALWAYS allowed** - no prior test output needed
   - Starting TDD for a new feature is always valid, even if test output shows unrelated work
   - For DOM-based tests, use \`data-testid\` attributes to select elements rather than CSS classes, tag names, or text content
   - Avoid hard-coded timeouts both in form of sleep() or timeout: 5000 etc; use proper async patterns (\`waitFor\`, \`findBy*\`, event-based sync) instead and rely on global test configs for timeout settings

2. **Green Phase**: Write MINIMAL code to make the test pass

   - Implement only what's needed for the current failing test
   - No anticipatory coding or extra features
   - Address the specific failure message

3. **Refactor Phase**: Improve code structure while keeping tests green
   - Only allowed when relevant tests are passing
   - Requires proof that tests have been run and are green
   - Applies to BOTH implementation and test code
   - No refactoring with failing tests - fix them first

### Core Violations

1. **Multiple Test Addition**

   - Adding more than one new test at once
   - Exception: Initial test file setup or extracting shared test utilities

2. **Over-Implementation**

   - Code that exceeds what's needed to pass the current failing test
   - Adding untested features, methods, or error handling
   - Implementing multiple methods when test only requires one

3. **Premature Implementation**
   - Adding implementation before a test exists and fails properly
   - Adding implementation without running the test first
   - Refactoring when tests haven't been run or are failing

### Critical Principle: Incremental Development

Each step in TDD should address ONE specific issue:

- Test fails "not defined" ‚Üí Create empty stub/class only
- Test fails "not a function" ‚Üí Add method stub only
- Test fails with assertion ‚Üí Implement minimal logic only

### Optional Pre-Phase: Spike Phase

In rare cases where the problem space, interface, or expected behavior is unclear, a **Spike Phase** may be used **before the Red Phase**.
This phase is **not part of the regular TDD workflow** and must only be applied under exceptional circumstances.

- The goal of a Spike is **exploration and learning**, not implementation.
- The code written during a Spike is **disposable** and **must not** be merged or reused directly.
- Once sufficient understanding is achieved, all spike code is discarded, and normal TDD resumes starting from the **Red Phase**.
- A Spike is justified only when it is impossible to define a meaningful failing test due to technical uncertainty or unknown system behavior.

### General Information

- Sometimes the test output shows as no tests have been run when a new test is failing due to a missing import or constructor. In such cases, allow the agent to create simple stubs. Ask them if they forgot to create a stub if they are stuck.
- It is never allowed to introduce new logic without evidence of relevant failing tests. However, stubs and simple implementation to make imports and test infrastructure work is fine.
- In the refactor phase, it is perfectly fine to refactor both test and implementation code. That said, completely new functionality is not allowed. Types, clean up, abstractions, and helpers are allowed as long as they do not introduce new behavior.
- Adding types, interfaces, or a constant in order to replace magic values is perfectly fine during refactoring.
- Provide the agent with helpful directions so that they do not get stuck when blocking them.

1. **Consistency check** - Look for inconsistent patterns, naming conventions, or structure across the codebase
"
`;

exports[`downloads/without-beads > should match snapshot for ship.md 1`] = `
"---
description: Ship code directly to main - for small, obvious changes that don't need review
argument-hint: [optional-commit-message]
---

# Ship - Direct Merge to Main

## General Guidelines

### Output Style

- **Never explicitly mention TDD** in code, comments, commits, PRs, or issues
- Write natural, descriptive code without meta-commentary about the development process
- The code should speak for itself - TDD is the process, not the product

**Ship/Show/Ask Pattern - SHIP**

Ship is for small, obvious changes that don't need code review. Examples:

- Typo fixes
- Formatting changes
- Documentation updates
- Obvious bug fixes
- Dependency updates with passing tests

## Prerequisites

Before shipping directly to main:

1. All tests must pass
2. Linter must pass
3. Changes must be small and low-risk
4. CI must be green (if configured)

## Workflow

Current branch status:
!\`git status\`

Recent commits:
!\`git log --oneline -5\`

Arguments: $ARGUMENTS

**Process:**

1. **Verify Change Size**: Check git diff to ensure changes are small and focused
   !\`git diff --stat main\`

2. **Run Tests**: Ensure all tests pass
   !\`npm test\` or !\`yarn test\` or appropriate test command for the project

3. **Run Linter**: Ensure code quality checks pass
   !\`npm run lint\` or !\`yarn lint\` or appropriate lint command (if available)

4. **Safety Check**: Confirm with user that this is truly a ship-worthy change:
   - Is this a small, obvious change?
   - Do all tests pass?
   - Is CI green?

   If ANY of these are "no", suggest using \`/show\` or \`/ask\` instead.

5. **Merge to Main**: If all checks pass and user confirms:

   \`\`\`bash
   git checkout main
   git pull origin main
   git merge --ff-only [feature-branch] || git merge [feature-branch]
   git push origin main
   \`\`\`

6. **Cleanup**: Delete the feature branch

   \`\`\`bash
   git branch -d [feature-branch]
   git push origin --delete [feature-branch]
   \`\`\`

7. **Notify**: Show summary of what was shipped

## Safety Rails

If tests fail, linter fails, or changes are large/complex, STOP and suggest:

- Use \`/show\` for changes that should be seen but don't need approval
- Use \`/ask\` (traditional PR) for complex changes needing discussion
"
`;

exports[`downloads/without-beads > should match snapshot for show.md 1`] = `
"---
description: Show code to team with auto-merge - for changes that should be visible but don't need approval
argument-hint: [optional-pr-title-and-description]
---

# Show - Visible Merge with Optional Feedback

## General Guidelines

### Output Style

- **Never explicitly mention TDD** in code, comments, commits, PRs, or issues
- Write natural, descriptive code without meta-commentary about the development process
- The code should speak for itself - TDD is the process, not the product

**Ship/Show/Ask Pattern - SHOW**

Show is for changes that teammates should see, but don't require approval. Examples:

- Refactoring with test coverage
- New features with comprehensive tests
- Performance improvements
- Non-breaking API changes

## Prerequisites

Before using show:

1. All tests must pass
2. Changes should have good test coverage
3. Changes should be non-breaking or backward compatible
4. CI must be green

## Workflow

Current branch status:
!\`git status\`

Recent commits:
!\`git log --oneline -5\`

Arguments: $ARGUMENTS

**Process:**

1. **Verify Quality**: Check that changes meet show criteria
   - Run tests: !\`npm test\` or !\`yarn test\` or appropriate test command
   - Check coverage is maintained or improved
   - Verify no breaking changes

2. **Create Show PR**: Create a PR that will auto-merge after a short window
   - Title: conventional commits format, prefixed with \`[SHOW]\`
   - Description: Clear explanation of what changed and why
   - Add label: "show" or "auto-merge"
   - Set auto-merge if GitHub setting allows

3. **Configure Auto-Merge**:
   - If GitHub Actions is configured, set to auto-merge after CI passes
   - If not, provide instructions to merge after 1-2 hours of visibility
   - Add notice that feedback is welcome but not required

4. **PR Description Template**:

   \`\`\`markdown
   ## üöÄ Show - Auto-merging after CI

   **This is a SHOW PR**: Changes are ready to merge but shared for visibility.
   Feedback welcome but not required. Will auto-merge when CI passes.

   <!--
     References: [link to relevant issues]
   -->

   ### What changed

   [Brief description]

   ### Why

   [Rationale for change]

   ### Test coverage

   - [ ] All tests pass
   - [ ] Coverage maintained/improved
   - [ ] No breaking changes
   \`\`\`

5. **Monitoring**: Check PR status and auto-merge when ready

## Decision Guide

Use **Show** when:

- ‚úÖ Tests are comprehensive
- ‚úÖ Changes are non-breaking
- ‚úÖ You're confident in the approach
- ‚úÖ Team should be aware of the change

Use **/ship** instead if: change is tiny and obvious (typo, formatting)

Use **/ask** instead if: change needs discussion, breaks APIs, or you're uncertain
"
`;

exports[`downloads/without-beads > should match snapshot for spike.md 1`] = `
"---
description: Execute TDD Spike Phase - exploratory coding to understand problem space before TDD
argument-hint: <exploration description>
---

SPIKE PHASE! Apply the below to the info given by user input here:

$ARGUMENTS

## General Guidelines

### Output Style

- **Never explicitly mention TDD** in code, comments, commits, PRs, or issues
- Write natural, descriptive code without meta-commentary about the development process
- The code should speak for itself - TDD is the process, not the product

(If there was no info above, fallback to the context of the conversation)

## TDD Fundamentals

### The TDD Cycle

The foundation of TDD is the Red-Green-Refactor cycle:

1. **Red Phase**: Write ONE failing test that describes desired behavior

   - The test must fail for the RIGHT reason (not syntax/import errors)
   - Only one test at a time - this is critical for TDD discipline
     - Exception: For browser-level tests or expensive setup (e.g., Storybook \`*.stories.tsx\`), group multiple assertions within a single test block to avoid redundant setup - but only when adding assertions to an existing interaction flow. If new user interactions are required, still create a new test. Split files by category if they exceed ~1000 lines.
   - **Adding a single test to a test file is ALWAYS allowed** - no prior test output needed
   - Starting TDD for a new feature is always valid, even if test output shows unrelated work
   - For DOM-based tests, use \`data-testid\` attributes to select elements rather than CSS classes, tag names, or text content
   - Avoid hard-coded timeouts both in form of sleep() or timeout: 5000 etc; use proper async patterns (\`waitFor\`, \`findBy*\`, event-based sync) instead and rely on global test configs for timeout settings

2. **Green Phase**: Write MINIMAL code to make the test pass

   - Implement only what's needed for the current failing test
   - No anticipatory coding or extra features
   - Address the specific failure message

3. **Refactor Phase**: Improve code structure while keeping tests green
   - Only allowed when relevant tests are passing
   - Requires proof that tests have been run and are green
   - Applies to BOTH implementation and test code
   - No refactoring with failing tests - fix them first

### Core Violations

1. **Multiple Test Addition**

   - Adding more than one new test at once
   - Exception: Initial test file setup or extracting shared test utilities

2. **Over-Implementation**

   - Code that exceeds what's needed to pass the current failing test
   - Adding untested features, methods, or error handling
   - Implementing multiple methods when test only requires one

3. **Premature Implementation**
   - Adding implementation before a test exists and fails properly
   - Adding implementation without running the test first
   - Refactoring when tests haven't been run or are failing

### Critical Principle: Incremental Development

Each step in TDD should address ONE specific issue:

- Test fails "not defined" ‚Üí Create empty stub/class only
- Test fails "not a function" ‚Üí Add method stub only
- Test fails with assertion ‚Üí Implement minimal logic only

### Optional Pre-Phase: Spike Phase

In rare cases where the problem space, interface, or expected behavior is unclear, a **Spike Phase** may be used **before the Red Phase**.
This phase is **not part of the regular TDD workflow** and must only be applied under exceptional circumstances.

- The goal of a Spike is **exploration and learning**, not implementation.
- The code written during a Spike is **disposable** and **must not** be merged or reused directly.
- Once sufficient understanding is achieved, all spike code is discarded, and normal TDD resumes starting from the **Red Phase**.
- A Spike is justified only when it is impossible to define a meaningful failing test due to technical uncertainty or unknown system behavior.

### General Information

- Sometimes the test output shows as no tests have been run when a new test is failing due to a missing import or constructor. In such cases, allow the agent to create simple stubs. Ask them if they forgot to create a stub if they are stuck.
- It is never allowed to introduce new logic without evidence of relevant failing tests. However, stubs and simple implementation to make imports and test infrastructure work is fine.
- In the refactor phase, it is perfectly fine to refactor both test and implementation code. That said, completely new functionality is not allowed. Types, clean up, abstractions, and helpers are allowed as long as they do not introduce new behavior.
- Adding types, interfaces, or a constant in order to replace magic values is perfectly fine during refactoring.
- Provide the agent with helpful directions so that they do not get stuck when blocking them.
"
`;

exports[`downloads/without-beads > should match snapshot for summarize.md 1`] = `
"---
description: Summarize conversation progress and next steps
argument-hint: [optional additional info]
---

## General Guidelines

### Output Style

- **Never explicitly mention TDD** in code, comments, commits, PRs, or issues
- Write natural, descriptive code without meta-commentary about the development process
- The code should speak for itself - TDD is the process, not the product

Create a concise summary of the current conversation suitable for transferring context to a new conversation.

Additional info: $ARGUMENTS

## Summary Structure

Provide a summary with these sections:

### What We Did

- Key accomplishments and changes made
- Important decisions or discoveries
- Files created, modified, or analyzed

### What We're Doing Next

- Immediate next steps
- Pending tasks or work in progress
- Goals or objectives to continue

### Blockers & User Input Needed

- Any issues requiring user intervention
- Decisions that need to be made
- Missing information or clarifications needed

## Output Format

Keep the summary concise and actionable - suitable for pasting into a new conversation to quickly restore context without needing the full conversation history.
"
`;

exports[`downloads/without-beads > should match snapshot for tdd.md 1`] = `
"---
description: Remind agent about TDD approach and continue conversation
argument-hint: [optional-response-to-last-message]
---

# TDD Reminder

## General Guidelines

### Output Style

- **Never explicitly mention TDD** in code, comments, commits, PRs, or issues
- Write natural, descriptive code without meta-commentary about the development process
- The code should speak for itself - TDD is the process, not the product

## TDD Fundamentals

### The TDD Cycle

The foundation of TDD is the Red-Green-Refactor cycle:

1. **Red Phase**: Write ONE failing test that describes desired behavior

   - The test must fail for the RIGHT reason (not syntax/import errors)
   - Only one test at a time - this is critical for TDD discipline
     - Exception: For browser-level tests or expensive setup (e.g., Storybook \`*.stories.tsx\`), group multiple assertions within a single test block to avoid redundant setup - but only when adding assertions to an existing interaction flow. If new user interactions are required, still create a new test. Split files by category if they exceed ~1000 lines.
   - **Adding a single test to a test file is ALWAYS allowed** - no prior test output needed
   - Starting TDD for a new feature is always valid, even if test output shows unrelated work
   - For DOM-based tests, use \`data-testid\` attributes to select elements rather than CSS classes, tag names, or text content
   - Avoid hard-coded timeouts both in form of sleep() or timeout: 5000 etc; use proper async patterns (\`waitFor\`, \`findBy*\`, event-based sync) instead and rely on global test configs for timeout settings

2. **Green Phase**: Write MINIMAL code to make the test pass

   - Implement only what's needed for the current failing test
   - No anticipatory coding or extra features
   - Address the specific failure message

3. **Refactor Phase**: Improve code structure while keeping tests green
   - Only allowed when relevant tests are passing
   - Requires proof that tests have been run and are green
   - Applies to BOTH implementation and test code
   - No refactoring with failing tests - fix them first

### Core Violations

1. **Multiple Test Addition**

   - Adding more than one new test at once
   - Exception: Initial test file setup or extracting shared test utilities

2. **Over-Implementation**

   - Code that exceeds what's needed to pass the current failing test
   - Adding untested features, methods, or error handling
   - Implementing multiple methods when test only requires one

3. **Premature Implementation**
   - Adding implementation before a test exists and fails properly
   - Adding implementation without running the test first
   - Refactoring when tests haven't been run or are failing

### Critical Principle: Incremental Development

Each step in TDD should address ONE specific issue:

- Test fails "not defined" ‚Üí Create empty stub/class only
- Test fails "not a function" ‚Üí Add method stub only
- Test fails with assertion ‚Üí Implement minimal logic only

### Optional Pre-Phase: Spike Phase

In rare cases where the problem space, interface, or expected behavior is unclear, a **Spike Phase** may be used **before the Red Phase**.
This phase is **not part of the regular TDD workflow** and must only be applied under exceptional circumstances.

- The goal of a Spike is **exploration and learning**, not implementation.
- The code written during a Spike is **disposable** and **must not** be merged or reused directly.
- Once sufficient understanding is achieved, all spike code is discarded, and normal TDD resumes starting from the **Red Phase**.
- A Spike is justified only when it is impossible to define a meaningful failing test due to technical uncertainty or unknown system behavior.

### General Information

- Sometimes the test output shows as no tests have been run when a new test is failing due to a missing import or constructor. In such cases, allow the agent to create simple stubs. Ask them if they forgot to create a stub if they are stuck.
- It is never allowed to introduce new logic without evidence of relevant failing tests. However, stubs and simple implementation to make imports and test infrastructure work is fine.
- In the refactor phase, it is perfectly fine to refactor both test and implementation code. That said, completely new functionality is not allowed. Types, clean up, abstractions, and helpers are allowed as long as they do not introduce new behavior.
- Adding types, interfaces, or a constant in order to replace magic values is perfectly fine during refactoring.
- Provide the agent with helpful directions so that they do not get stuck when blocking them.

## Continue Conversation

User response to the last message: $ARGUMENTS

Please continue with TDD approach based on the above response.
"
`;

exports[`downloads/without-beads > should match snapshot for worktree-add.md 1`] = `
"---
description: Add a new git worktree from branch name or issue URL, copy settings, install deps, and open in current IDE
argument-hint: <branch-name-or-issue-url> [optional-base-branch]
---

# Git Worktree Setup

## General Guidelines

### Output Style

- **Never explicitly mention TDD** in code, comments, commits, PRs, or issues
- Write natural, descriptive code without meta-commentary about the development process
- The code should speak for itself - TDD is the process, not the product

Create a new git worktree for branch: $ARGUMENTS

<current_state>
Current branch: \`git branch --show-current\`
Current worktrees: \`git worktree list\`
Remote branches: \`git branch -r\`
Uncommitted changes: \`git status --short\`
</current_state>

<execution_steps>
<step_0>
  <description>Ask user for setup mode</description>
  <prompt>
    <message>How would you like to set up the worktree?</message>
    <options>
      <option value="quick">
        <label>Quick</label>
        <description>Just create the worktree (skip deps, settings, IDE)</description>
      </option>
      <option value="full">
        <label>Full setup</label>
        <description>Install dependencies, copy settings, open in IDE</description>
      </option>
    </options>
  </prompt>
  <set_variable>$SETUP_MODE = user selection ("quick" or "full")</set_variable>
  <purpose>Allow quick worktree creation when user just needs the branch</purpose>
</step_0>

<step_0b>
  <description>Detect git hosting provider and available tools (only needed if argument is an issue URL)</description>
  <condition>Only run this step if first argument looks like a git hosting URL</condition>
<detect_provider>
  <check_remote_url>git remote get-url origin</check_remote_url>
  <identify_host>
    - github.com ‚Üí GitHub
    - gitlab.com ‚Üí GitLab
    - bitbucket.org ‚Üí Bitbucket
    - Other ‚Üí Ask user
  </identify_host>
</detect_provider>
<check_available_tools>
  <list_mcp_servers>Check which git-hosting MCP servers are available (github, gitlab, etc.)</list_mcp_servers>
  <check_cli>Check if gh/glab CLI is available as fallback</check_cli>
</check_available_tools>
<select_tool>
  <if_single_mcp>If only one relevant MCP available, confirm with user</if_single_mcp>
  <if_multiple>Let user choose which tool to use</if_multiple>
  <if_told_earlier>If user specified tool earlier in conversation, use that without asking again</if_told_earlier>
  <store_as>$GIT_HOST_TOOL (e.g., "github_mcp", "gitlab_mcp", "gh_cli")</store_as>
</select_tool>

  <purpose>Detect git hosting provider and select appropriate tool for issue lookup</purpose>
</step_0b>

  <step_1>
    <description>Detect current IDE environment</description>
    <condition>Only if $SETUP_MODE is "full"</condition>
    <detection_methods>
      <method_1>
        <tool>mcp__ide__getDiagnostics</tool>
        <vs_code_insiders>Check for paths containing "Code - Insiders"</vs_code_insiders>
        <vs_code>Check for paths containing "Code/" or "Code.app"</vs_code>
        <cursor>Check for paths containing "Cursor"</cursor>
        <zed>Check for paths containing "Zed"</zed>
      </method_1>
      <method_2>
        <fallback_detection>Use which command to find available IDEs</fallback_detection>
        <commands>which code-insiders code zed cursor</commands>
        <priority_order>code-insiders > cursor > zed > code</priority_order>
      </method_2>
    </detection_methods>
    <set_variables>
      <ide_command>Detected command (code-insiders|code|zed|cursor)</ide_command>
      <ide_name>Human-readable name</ide_name>
      <supports_tasks>true for VS Code variants, false for others</supports_tasks>
    </set_variables>
    <purpose>Automatically detect which IDE to use for opening the new worktree</purpose>
  </step_1>

  <step_2>
    <description>Determine default branch and parse arguments</description>
    <find_default_branch>
      <command>git symbolic-ref refs/remotes/origin/HEAD | sed 's@^refs/remotes/origin/@@'</command>
      <fallback>git remote show origin | grep 'HEAD branch' | cut -d: -f2 | tr -d ' '</fallback>
      <store_as>$DEFAULT_BRANCH (typically "main" or "master")</store_as>
    </find_default_branch>
    <input>The user-provided arguments</input>
    <expected_format>branch-name-or-issue-url [optional-base-branch]</expected_format>
    <example>fix/issue-123-main-content-area-visually-clipped main</example>
    <example_issue_url>https://github.com/owner/project/issues/123 main</example_issue_url>
    <base_branch>Use provided base branch, or $DEFAULT_BRANCH if not specified</base_branch>
  </step_2>

  <step_2_5>
    <description>Handle issue URLs from git hosting provider</description>
    <condition>If first argument matches issue URL pattern (detected in step_0)</condition>
    <url_detection>
      <github>Check if argument contains "github.com" and "/issues/"</github>
      <gitlab>Check if argument contains "gitlab.com" and "/-/issues/"</gitlab>
      <bitbucket>Check if argument contains "bitbucket.org" and "/issues/"</bitbucket>
    </url_detection>
    <url_parsing>
      <github_pattern><https://github.com/{owner}/{repo}/issues/{issue_number}></github_pattern>
      <gitlab_pattern><https://gitlab.com/{owner}/{repo}/-/issues/{issue_number}></gitlab_pattern>
      <bitbucket_pattern><https://bitbucket.org/{owner}/{repo}/issues/{issue_number}></bitbucket_pattern>
      <extract>owner, repo, issue_number from URL</extract>
    </url_parsing>
    <fetch_issue_details>
      <tool>Use $GIT_HOST_TOOL from step_0</tool>
      <method>get issue details</method>
      <parameters>owner, repo, issue_number</parameters>
    </fetch_issue_details>
    <generate_branch_name>
      <determine_type>Analyze issue title/labels to determine type (feat/fix/refactor/chore)</determine_type>
      <format>{type}/issue-{issue_number}-{kebab-case-title}</format>
      <kebab_case>Convert title to lowercase, replace spaces/special chars with hyphens</kebab_case>
      <sanitization>
        <rule>Always use lowercase for branch names</rule>
        <rule>Replace # with - (hash symbol not allowed in git branch names)</rule>
        <rule>Remove or replace other special characters: @, $, %, ^, &, *, (, ), [, ], {, }, \\, |, ;, :, ", ', <, >, ?, /, ~, \`</rule>
        <rule>Replace multiple consecutive hyphens with single hyphen</rule>
        <rule>Trim leading/trailing hyphens</rule>
      </sanitization>
      <truncate>Limit total branch name to reasonable length (~60 chars)</truncate>
    </generate_branch_name>
    <user_confirmation>
      <display>Show generated branch name and ask for confirmation</display>
      <options>"Yes, proceed" or "No, exit" or "Edit branch name"</options>
      <if_no>Exit command gracefully</if_no>
      <if_edit>Allow user to modify the branch name</if_edit>
      <if_yes>Continue with generated/modified branch name</if_yes>
    </user_confirmation>
    <examples>
      <input>https://github.com/owner/project/issues/456</input>
      <title>"Fix duplicate items in list view"</title>
      <generated>fix/issue-456-duplicate-items-in-list-view</generated>
    </examples>
  </step_2_5>

  <step_3>
    <description>Handle uncommitted changes if any exist</description>
    <condition>If git status --short output is not empty (has uncommitted changes)</condition>
    <prompt>
      <message>You have uncommitted changes. Move them to the new branch?</message>
      <options>
        <option value="yes">
          <label>Yes</label>
          <description>Stash changes and apply them in the new worktree</description>
        </option>
        <option value="no">
          <label>No</label>
          <description>Leave changes in current branch</description>
        </option>
      </options>
    </prompt>
    <if_yes>
      <command>git add -A && git stash push -m "Worktree switch: Moving changes to \${branch_name}"</command>
      <set_variable>$STASH_CREATED = true</set_variable>
    </if_yes>
    <if_no>
      <set_variable>$STASH_CREATED = false</set_variable>
    </if_no>
    <purpose>Let user decide whether to move work in progress to new branch</purpose>
  </step_3>

  <step_4>
    <description>Determine worktree parent directory</description>
    <check_if_in_worktree>git rev-parse --is-inside-work-tree && git worktree list --porcelain | grep "$(git rev-parse --show-toplevel)"</check_if_in_worktree>
    <set_parent_path>
      <if_main_worktree>Set parent_path=".."</if_main_worktree>
      <if_secondary_worktree>Set parent_path="../.." (need to go up two levels)</if_secondary_worktree>
    </set_parent_path>
    <purpose>Correctly determine where to create new worktree regardless of current location</purpose>
    <note>This handles both main worktree and secondary worktree scenarios</note>
  </step_4>

  <step_5>
    <description>Fetch latest changes from remote</description>
    <command>git fetch origin</command>
    <purpose>Ensure we have the latest remote branches and default branch state</purpose>
    <note>This ensures new worktrees are created from the most recent default branch</note>
  </step_5>

  <step_6>
    <description>Check if branch exists on remote</description>
    <command>git branch -r | grep "origin/\${branch_name}"</command>
    <decision>
      <if_exists>Branch exists on remote - will checkout existing branch</if_exists>
      <if_not_exists>Branch does not exist - will create new branch from base</if_not_exists>
    </decision>
  </step_6>

  <step_7>
    <description>Create the worktree</description>
    <option_a_new_branch>
      <condition>Remote branch does NOT exist</condition>
      <command>git worktree add \${parent_path}/\${branch_name} -b \${branch_name} \${base_branch}</command>
      <example>git worktree add ../fix/issue-123-main-content-area-visually-clipped -b fix/issue-123-main-content-area-visually-clipped main</example>
    </option_a_new_branch>
    <option_b_existing_branch>
      <condition>Remote branch EXISTS</condition>
      <command>git worktree add \${parent_path}/\${branch_name} \${branch_name}</command>
      <example>git worktree add ../fix/issue-123-main-content-area-visually-clipped fix/issue-123-main-content-area-visually-clipped</example>
    </option_b_existing_branch>
  </step_7>

  <step_7b>
    <description>Set up remote tracking for new branch</description>
    <condition>Only if new branch was created (option_a from step_7)</condition>
    <working_directory>\${parent_path}/\${branch_name}</working_directory>
    <command>cd \${parent_path}/\${branch_name} && git push -u origin \${branch_name}</command>
    <purpose>Establish remote tracking so git status shows ahead/behind and git push/pull work without specifying remote</purpose>
    <note>This creates the remote branch and sets upstream tracking in one step</note>
  </step_7b>

  <step_7c>
    <description>Quick mode completion</description>
    <condition>Only if $SETUP_MODE is "quick"</condition>
    <message>Worktree created at: \${parent_path}/\${branch_name}</message>
    <suggested_next_steps>
      <intro>You can now:</intro>
      <suggestion priority="1">Open in VS Code: \`code \${parent_path}/\${branch_name}\`</suggestion>
      <suggestion priority="2">Open in Cursor: \`cursor \${parent_path}/\${branch_name}\`</suggestion>
      <suggestion priority="3">Navigate to it: \`cd \${parent_path}/\${branch_name}\`</suggestion>
      <suggestion priority="4">Install dependencies: \`cd \${parent_path}/\${branch_name} && pnpm install\`</suggestion>
    </suggested_next_steps>
    <action>STOP here - do not continue to remaining steps</action>
  </step_7c>

  <step_8>
    <description>Copy Claude settings to new worktree</description>
    <condition>Only if $SETUP_MODE is "full"</condition>
    <source>.claude/settings.local.json</source>
    <destination>\${parent_path}/\${branch_name}/.claude/settings.local.json</destination>
    <command>cp -r .claude/settings.local.json \${parent_path}/\${branch_name}/.claude/settings.local.json</command>
    <purpose>Preserve all permission settings and configurations</purpose>
  </step_8>

  <step_9>
    <description>Copy .env.local files to new worktree</description>
    <condition>Only if $SETUP_MODE is "full"</condition>
    <search_command>find . -name ".env.local" -type f</search_command>
    <copy_logic>For each .env.local file found, copy to corresponding location in new worktree</copy_logic>
    <common_locations>
      - app/.env.local
      - packages/*/.env.local
      - (any other .env.local files found)
    </common_locations>
    <copy_command>find . -name ".env.local" -type f -exec sh -c 'mkdir -p "$(dirname "\${parent_path}/\${branch_name}/$1")" && cp "$1" "\${parent_path}/\${branch_name}/$1"'_ {} \\;</copy_command>
    <purpose>Preserve local environment configurations for development</purpose>
    <note>Only copies files that exist; ignores missing ones</note>
  </step_9>

  <step_10>
    <description>Create IDE-specific configuration (conditional)</description>
    <condition>Only if $SETUP_MODE is "full" AND supports_tasks is true (VS Code variants)</condition>
    <vs_code_tasks>
      <create_directory>mkdir -p \${parent_path}/\${branch_name}/.vscode</create_directory>
      <create_file_command>cat > \${parent_path}/\${branch_name}/.vscode/tasks.json << 'EOF'
{
  "version": "2.0.0",
  "tasks": [
    {
      "label": "Auto start Claude",
      "type": "shell",
      "command": "claude",
      "runOptions": {
        "runOn": "folderOpen"
      },
      "presentation": {
        "echo": false,
        "reveal": "always",
        "focus": true,
        "panel": "new"
      }
    }
  ]
}
EOF</create_file_command>
    </vs_code_tasks>
    <purpose>Create auto-start Claude task for VS Code variants on folder open</purpose>
    <note>Only creates for VS Code variants (code, code-insiders, cursor)</note>
    <skip_message>Skipping IDE-specific config for non-VS Code IDEs</skip_message>
  </step_10>

  <step_11>
    <description>Install dependencies in new worktree</description>
    <condition>Only if $SETUP_MODE is "full"</condition>
    <working_directory>\${parent_path}/\${branch_name}</working_directory>
    <command>cd \${parent_path}/\${branch_name} && pnpm install</command>
    <purpose>Ensure all node_modules are installed for the new worktree</purpose>
  </step_11>

  <step_12>
    <description>Apply stashed changes to new worktree (if stash was created)</description>
    <condition>Only if $SETUP_MODE is "full" AND $STASH_CREATED is true</condition>
    <working_directory>\${parent_path}/\${branch_name}</working_directory>
    <command>cd \${parent_path}/\${branch_name} && git stash pop</command>
    <purpose>Restore uncommitted work-in-progress to the new worktree branch</purpose>
    <note>This moves your uncommitted changes to the new branch where you'll continue working</note>
  </step_12>

  <step_13>
    <description>Open detected IDE in new worktree</description>
    <condition>Only if $SETUP_MODE is "full"</condition>
    <command>\${ide_command} \${parent_path}/\${branch_name}</command>
    <ide_specific_behavior>
      <vs_code_variants>Opens folder in VS Code/Insiders/Cursor with tasks.json auto-starting Claude</vs_code_variants>
      <zed>Opens folder in Zed editor</zed>
      <other>Uses detected IDE command to open folder</other>
    </ide_specific_behavior>
    <purpose>Launch development environment for the new worktree using detected IDE</purpose>
    <confirmation_message>Opening worktree in \${ide_name}</confirmation_message>
  </step_13>
</execution_steps>

<important_notes>

- Offers Quick or Full setup mode - Quick just creates the worktree, Full does everything
- Automatically detects and uses your current IDE (VS Code, VS Code Insiders, Cursor, Zed, etc.) in Full mode
- Creates VS Code-specific tasks.json only for VS Code variants (auto-starts Claude on folder open)
- Branch names with slashes (feat/, fix/, etc.) are fully supported
- The worktree directory path will match the full branch name including slashes
- Settings are copied to maintain the same permissions across worktrees
- Environment files (.env.local) are copied to preserve local configurations
- Each worktree has its own node_modules installation
- Uncommitted changes are automatically stashed and moved to the new worktree
- Your work-in-progress seamlessly transfers to the new branch
- IDE detection fallback: checks available editors and uses priority order
- New branches are automatically pushed with \`-u\` to set up remote tracking

Limitations:

- Assumes remote is named "origin" (most common convention)
- Supports macOS and Linux only (no Windows support)
- Requires MCP server or CLI for git hosting provider when using issue URLs (GitHub, GitLab, etc.)
- Dependency install command is pnpm (modify for npm/yarn if needed)
</important_notes>
"
`;

exports[`downloads/without-beads > should match snapshot for worktree-cleanup.md 1`] = `
"---
description: Clean up merged worktrees by verifying PR/issue status, consolidating settings, and removing stale worktrees
argument-hint: (no arguments)
---

# Worktree Cleanup

## General Guidelines

### Output Style

- **Never explicitly mention TDD** in code, comments, commits, PRs, or issues
- Write natural, descriptive code without meta-commentary about the development process
- The code should speak for itself - TDD is the process, not the product

Clean up merged worktrees by finding the oldest merged branch, consolidating settings, and removing stale worktrees.

Additional info: $ARGUMENTS

<current_state>
Current branch: \`git branch --show-current\`
Current worktrees: \`git worktree list\`
</current_state>

<execution_steps>
<step_0>
  <description>Detect git hosting provider and available tools</description>
<detect_provider>
  <check_remote_url>git remote get-url origin</check_remote_url>
  <identify_host>
    - github.com ‚Üí GitHub
    - gitlab.com ‚Üí GitLab
    - bitbucket.org ‚Üí Bitbucket
    - Other ‚Üí Ask user
  </identify_host>
</detect_provider>
<check_available_tools>
  <list_mcp_servers>Check which git-hosting MCP servers are available (github, gitlab, etc.)</list_mcp_servers>
  <check_cli>Check if gh/glab CLI is available as fallback</check_cli>
</check_available_tools>
<select_tool>
  <if_single_mcp>If only one relevant MCP available, confirm with user</if_single_mcp>
  <if_multiple>Let user choose which tool to use</if_multiple>
  <if_told_earlier>If user specified tool earlier in conversation, use that without asking again</if_told_earlier>
  <store_as>$GIT_HOST_TOOL (e.g., "github_mcp", "gitlab_mcp", "gh_cli")</store_as>
</select_tool>

  <purpose>Detect git hosting provider and select appropriate tool for PR verification</purpose>
</step_0>

  <step_1>
    <description>Determine default branch and verify we're on it</description>
    <find_default_branch>
      <command>git symbolic-ref refs/remotes/origin/HEAD | sed 's@^refs/remotes/origin/@@'</command>
      <fallback>git remote show origin | grep 'HEAD branch' | cut -d: -f2 | tr -d ' '</fallback>
      <store_as>$DEFAULT_BRANCH (typically "main" or "master")</store_as>
    </find_default_branch>
    <check_current_branch>git branch --show-current</check_current_branch>
    <verify>Current branch must equal $DEFAULT_BRANCH</verify>
    <error_if_not_default>Exit with error: "This command must be run from the default branch ($DEFAULT_BRANCH)"</error_if_not_default>
    <purpose>Ensure we're consolidating to the default branch worktree</purpose>
  </step_1>

  <step_2>
    <description>Get list of all worktrees</description>
    <command>git worktree list --porcelain</command>
    <parse_output>Extract worktree paths and branch names</parse_output>
    <exclude_default>Filter out the default branch worktree from cleanup candidates</exclude_default>
    <purpose>Identify all worktrees that could potentially be cleaned up</purpose>
  </step_2>

  <step_3>
    <description>Find oldest worktree by directory age</description>
    <get_worktree_ages>
      <detect_platform>uname -s (returns "Darwin" for macOS, "Linux" for Linux)</detect_platform>
      <command_macos>git worktree list | grep -v "\\[$DEFAULT_BRANCH\\]" | awk '{print $1}' > /tmp/worktrees-$$.txt && while IFS= read -r path; do echo "$(/usr/bin/stat -f '%Sm' -t '%Y-%m-%d %H:%M' "$path" 2>/dev/null)|$path"; done < /tmp/worktrees-$$.txt | sort; rm -f /tmp/worktrees-$$.txt</command_macos>
      <command_linux>git worktree list | grep -v "\\[$DEFAULT_BRANCH\\]" | awk '{print $1}' > /tmp/worktrees-$$.txt && while IFS= read -r path; do echo "$(stat -c '%y' "$path" 2>/dev/null | cut -d. -f1)|$path"; done < /tmp/worktrees-$$.txt | sort; rm -f /tmp/worktrees-$$.txt</command_linux>
      <purpose>List all worktrees sorted by directory modification time (oldest first)</purpose>
      <critical_notes>
        - Replace $DEFAULT_BRANCH with value from step_1 (e.g., "main" or "master")
        - grep "\\[branch\\]" matches branch name in brackets, not paths containing the word
        - Temp file approach avoids subshell parsing issues with piped while-loops
        - /usr/bin/stat on macOS avoids homebrew stat conflicts
      </critical_notes>
      <expected_output_format>YYYY-MM-DD HH:MM|/full/path/to/worktree (oldest first)</expected_output_format>
    </get_worktree_ages>
    <filter_recent>
      <exclude_new>For worktrees created within the last 24 hours, let user know that this worktree might not be worth cleaning</exclude_new>
      <get_current_time>date +"%Y-%m-%d %H:%M"</get_current_time>
    </filter_recent>
    <select_oldest>
      <extract_branch_name>Parse branch name from oldest worktree path</extract_branch_name>
      <important_note>DO NOT use "git branch --merged" to check merge status - it's unreliable</important_note>
      <proceed_to_pr_check>Move directly to step 4 to verify PR merge status instead</proceed_to_pr_check>
    </select_oldest>
    <purpose>Identify oldest worktree candidate - actual merge verification happens via PR/MR in next step</purpose>
  </step_3>

  <step_4>
    <description>Verify PR/MR merge status (primary merge verification)</description>
    <determine_repo>
      <check_remote>git remote get-url origin</check_remote>
      <parse_repo>Extract owner/repo from remote URL</parse_repo>
    </determine_repo>
    <search_pr>
      <tool>Use $GIT_HOST_TOOL from step_0 (e.g., mcp__github__search_pull_requests, mcp__gitlab__*, or gh CLI)</tool>
      <query>Find PRs/MRs where head={branch_name} and base=$DEFAULT_BRANCH</query>
      <purpose>Find PR/MR for this branch targeting default branch</purpose>
      <important>This is the PRIMARY way to verify if a branch was merged - NOT git commands</important>
    </search_pr>
    <verify_pr_merged>
      <if_pr_found>
        <get_pr_details>Use $GIT_HOST_TOOL to get full PR/MR info</get_pr_details>
        <confirm_merged>Verify PR/MR state is "closed"/"merged" AND merged_at is not null AND base is "$DEFAULT_BRANCH"</confirm_merged>
        <extract_issue_number>Look for issue references in PR title/body (e.g., #123, owner/repo#123)</extract_issue_number>
        <if_merged>Proceed with cleanup - this branch was definitively merged to default branch</if_merged>
        <if_not_merged>
          <skip_worktree>This worktree is NOT merged - continue to next oldest worktree</skip_worktree>
          <repeat_from_step_3>Go back and find the next oldest worktree to check</repeat_from_step_3>
        </if_not_merged>
      </if_pr_found>
      <if_no_pr>
        <skip_worktree>No PR found - this branch was likely never submitted for review</skip_worktree>
        <continue_to_next>Continue checking next oldest worktree</continue_to_next>
      </if_no_pr>
    </verify_pr_merged>
    <purpose>Use PR/MR status as the authoritative source for merge verification instead of unreliable git commands</purpose>
  </step_4>

  <step_4_5>
    <description>Check and close related issue</description>
    <if_issue_found>
      <get_issue_details>
        <tool>Use $GIT_HOST_TOOL to read issue details</tool>
        <extract_repo>From issue reference (main-repo vs cross-repo)</extract_repo>
      </get_issue_details>
      <check_issue_state>
        <if_open>
          <ask_close>Ask user: "Related issue #{number} is still open. Should I close it? (y/N)"</ask_close>
          <if_yes_close>
            <add_closing_comment>
              <tool>Use $GIT_HOST_TOOL to add comment</tool>
              <body_template>Closing this issue as branch {branch_name} was merged to {default_branch} on {merge_date} via PR/MR #{pr_number}.</body_template>
              <get_merge_date>Extract merge date from PR/MR details</get_merge_date>
              <get_pr_number>Use PR/MR number from search results</get_pr_number>
            </add_closing_comment>
            <close_issue>
              <tool>Use $GIT_HOST_TOOL to close issue</tool>
              <state>closed</state>
              <state_reason>completed</state_reason>
            </close_issue>
          </if_yes_close>
        </if_open>
        <if_closed>Inform user issue is already closed</if_closed>
      </check_issue_state>
    </if_issue_found>
    <if_no_issue>Continue without issue management</if_no_issue>
    <purpose>Ensure proper issue lifecycle management</purpose>
  </step_4_5>

  <step_5>
    <description>Check if worktree is locked</description>
    <check_command>git worktree list --porcelain | grep -A5 "worktree {path}" | grep "locked"</check_command>
    <if_locked>
      <unlock_command>git worktree unlock {path}</unlock_command>
      <notify_user>Inform user that worktree was unlocked</notify_user>
    </if_locked>
    <purpose>Unlock worktree if it was locked for tracking purposes</purpose>
  </step_5>

  <step_6>
    <description>Analyze Claude settings differences</description>
    <read_main_settings>.claude/settings.local.json</read_main_settings>
    <read_worktree_settings>{worktree_path}/.claude/settings.local.json</read_worktree_settings>
    <compare_allow_lists>
      <extract_main_allows>Extract "allow" array from main settings</extract_main_allows>
      <extract_worktree_allows>Extract "allow" array from worktree settings</extract_worktree_allows>
      <find_differences>Identify entries in worktree that are not in main</find_differences>
    </compare_allow_lists>
    <filter_suggestions>
      <include_filesystem>Read permissions for filesystem paths</include_filesystem>
      <exclude_intrusive>Exclude bash commands, write permissions, etc.</exclude_intrusive>
      <focus_user_specific>Include only user-specific, non-disruptive entries</focus_user_specific>
    </filter_suggestions>
    <purpose>Identify useful settings to consolidate before cleanup</purpose>
  </step_6>

  <step_7>
    <description>Suggest settings consolidation</description>
    <if_differences_found>
      <display_suggestions>Show filtered differences to user</display_suggestions>
      <ask_confirmation>Ask user which entries to add to main settings</ask_confirmation>
      <apply_changes>Update main .claude/settings.local.json with selected entries</apply_changes>
    </if_differences_found>
    <if_no_differences>Inform user no settings need consolidation</if_no_differences>
    <purpose>Preserve useful development settings before removing worktree</purpose>
  </step_7>

  <step_8>
    <description>Final cleanup confirmation</description>
    <summary>
      <display_worktree>Show worktree path and branch name</display_worktree>
      <show_pr_status>Show merged PR details if found</show_pr_status>
      <show_issue_status>Show related issue status if found</show_issue_status>
      <show_last_activity>Display directory creation/modification date</show_last_activity>
    </summary>
    <safety_checks>
      <check_uncommitted>git status --porcelain in worktree directory</check_uncommitted>
      <warn_if_dirty>Alert user if uncommitted changes exist</warn_if_dirty>
    </safety_checks>
    <ask_deletion>Ask user confirmation: "Delete this worktree? (y/N)"</ask_deletion>
    <purpose>Final safety check before irreversible deletion</purpose>
  </step_8>

  <step_9>
    <description>Delete worktree</description>
    <if_confirmed>
      <remove_worktree>git worktree remove {path} --force</remove_worktree>
      <cleanup_branch>git branch -d {branch_name}</cleanup_branch>
      <success_message>Inform user worktree was successfully removed</success_message>
      <next_steps>Suggest running command again to find next candidate</next_steps>
    </if_confirmed>
    <if_declined>Exit gracefully with no changes</if_declined>
    <purpose>Perform the actual cleanup and guide user for next iteration</purpose>
  </step_9>
</execution_steps>

<important_notes>

- Uses PR/MR merge status as the ONLY reliable way to verify if a branch was merged
- DOES NOT use "git branch --merged" command as it's unreliable for merge verification
- Only processes branches with PRs/MRs that were definitively merged to default branch
- Skips worktrees without merged PRs/MRs and continues to next oldest candidate
- Checks and optionally closes related issues
- Prioritizes oldest worktrees by directory age first for systematic cleanup
- Warns about very recent worktrees (created within 24 hours) to avoid cleaning active work
- Preserves useful development settings before deletion
- Requires explicit confirmation before any destructive actions
- Handles locked worktrees automatically
- Processes one worktree at a time to maintain control
- Must be run from default branch for safety

Limitations:

- Assumes remote is named "origin" (most common convention)
- Supports macOS and Linux only (no Windows support)
- Requires MCP server or CLI for git hosting provider (GitHub, GitLab, etc.)
</important_notes>
"
`;
